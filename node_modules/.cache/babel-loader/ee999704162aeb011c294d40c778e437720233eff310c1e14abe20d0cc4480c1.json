{"ast":null,"code":"/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { Buffer } from 'buffer';\nimport { encodeAddress, decodeAddress } from '../encoding/address';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint';\nimport { concatArrays } from '../utils/utils';\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\nexport class ABIType {\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str) {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = string => [...string].every(c => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));\n      const tupleTypes = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\nexport class ABIUintType extends ABIType {\n  constructor(size) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n  equals(other) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIUfixedType extends ABIType {\n  constructor(size, denominator) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n  equals(other) {\n    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n  equals(other) {\n    return other instanceof ABIAddressType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n    // Return the address if it is already in bytes\n    if (value.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return value;\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n  equals(other) {\n    return other instanceof ABIBoolType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n  equals(other) {\n    return other instanceof ABIByteType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n  equals(other) {\n    return other instanceof ABIStringType;\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    const encodedBytes = Buffer.from(value);\n    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);\n    }\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);\n    if (byteLength !== byteValue.length) {\n      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);\n    }\n    return Buffer.from(byteValue).toString('utf-8');\n  }\n}\nexport class ABIArrayStaticType extends ABIType {\n  constructor(argType, arrayLength) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(`static array must have a non negative length: ${arrayLength}`);\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n  decode(byteString) {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\nexport class ABIArrayDynamicType extends ABIType {\n  constructor(argType) {\n    super();\n    this.childType = argType;\n  }\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));\n  }\n  toABITupleType(length) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\nexport class ABITupleType extends ABIType {\n  constructor(argTypes) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error('tuple type child type number larger than maximum uint16 error');\n    }\n    this.childTypes = argTypes;\n  }\n  toString() {\n    const typeStrings = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n  equals(other) {\n    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));\n  }\n  isDynamic() {\n    const isDynamic = child => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads = [];\n    const tails = [];\n    const isDynamicIndex = new Map();\n    let i = 0;\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error('expected before index should have number of bool mod 8 equal 0');\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(`byte length of ${headValue} should not exceed a uint16`);\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n    return concatArrays(...heads, ...tails);\n  }\n  decode(byteString) {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments = [];\n    const valuePartition = [];\n    let i = 0;\n    let iterIndex = 0;\n    const buf = Buffer.from(byteString);\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error('dynamic index segment miscalculation: left is greater than right index');\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg = {\n          left: dynamicIndex,\n          right: -1\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error('dynamic segment should display a [l, r] space with l <= r');\n      }\n      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);\n        segIndex += 1;\n      }\n    }\n    // Decode each tuple element\n    const returnValues = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n  static parseTupleContent(str) {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n    const tupleStrings = [];\n    let depth = 0;\n    let word = '';\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList) {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << 7 - i;\n    }\n  }\n  return res;\n}\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList, index, delta) {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}","map":{"version":3,"names":["Buffer","encodeAddress","decodeAddress","bigIntToBytes","bytesToBigInt","concatArrays","MAX_LEN","ADDR_BYTE_SIZE","SINGLE_BYTE_SIZE","SINGLE_BOOL_SIZE","LENGTH_ENCODE_BYTE_SIZE","staticArrayRegexp","ufixedRegexp","ABIType","from","str","endsWith","arrayArgType","slice","length","ABIArrayDynamicType","stringMatches","match","Error","arrayLengthStr","arrayLength","parseInt","arrayType","ABIArrayStaticType","startsWith","digitsOnly","string","every","c","includes","typeSizeStr","typeSize","ABIUintType","ABIByteType","ufixedSize","ufixedPrecision","ABIUfixedType","ABIBoolType","ABIAddressType","ABIStringType","tupleContent","ABITupleType","parseTupleContent","tupleTypes","i","ti","push","constructor","size","bitSize","toString","equals","other","isDynamic","byteLen","encode","value","BigInt","Number","isSafeInteger","decode","byteString","denominator","precision","Uint8Array","decodedAddress","publicKey","byteLength","encodedBytes","encodedLength","mergedBytes","set","buf","readUIntBE","byteValue","argType","childType","staticLength","Math","ceil","Array","isArray","convertedTuple","toABITupleType","fill","encodedTuple","childTypes","argTypes","typeStrings","join","child","index","some","after","findBoolLR","boolNum","trunc","childByteSize","values","heads","tails","isDynamicIndex","Map","tupleType","before","min","compressedInt","compressMultipleBool","encodedTupleValue","headLength","headElement","tailLength","j","get","headValue","dynamicSegments","valuePartition","iterIndex","dynamicIndex","right","left","seg","boolIndex","boolMask","currLen","segIndex","returnValues","valueTi","tupleStrings","depth","word","char","valueList","res","boolVal","typeList","delta","until","curr"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/node_modules/algosdk/src/abi/abi_type.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { Buffer } from 'buffer';\nimport { encodeAddress, decodeAddress } from '../encoding/address';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint';\nimport { concatArrays } from '../utils/utils';\n\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\n\ninterface Segment {\n  left: number;\n  right: number;\n}\n\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\n\nexport type ABIValue =\n  | boolean\n  | number\n  | bigint\n  | string\n  | Uint8Array\n  | ABIValue[];\n\nexport abstract class ABIType {\n  // Converts a ABIType object to a string\n  abstract toString(): string;\n  // Checks if two ABIType objects are equal in value\n  abstract equals(other: ABIType): boolean;\n  // Checks if the ABIType object (or any of its child types) have dynamic length\n  abstract isDynamic(): boolean;\n  // Returns the size of the ABIType object in bytes\n  abstract byteLen(): number;\n  // Encodes a value for the ABIType object using the ABI specs\n  abstract encode(value: ABIValue): Uint8Array;\n  // Decodes a value for the ABIType object using the ABI specs\n  abstract decode(byteString: Uint8Array): ABIValue;\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str: string): ABIType {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = (string) =>\n        [...string].every((c) => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(\n        str.slice(1, str.length - 1)\n      );\n      const tupleTypes: ABIType[] = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\n\nexport class ABIUintType extends ABIType {\n  bitSize: number;\n\n  constructor(size: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIUfixedType extends ABIType {\n  bitSize: number;\n  precision: number;\n\n  constructor(size: number, denominator: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIUfixedType &&\n      this.bitSize === other.bitSize &&\n      this.precision === other.precision\n    );\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size ${this.toString()}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIAddressType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n    // Return the address if it is already in bytes\n    if (value.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return value;\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\n\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIBoolType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n\n  decode(byteString: Uint8Array): boolean {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\n\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIByteType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n\n  decode(byteString: Uint8Array): number {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\n\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIStringType;\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    const encodedBytes = Buffer.from(value);\n    const encodedLength = bigIntToBytes(\n      encodedBytes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = new Uint8Array(\n      encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE\n    );\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(\n        `byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`\n      );\n    }\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteValue = byteString.slice(\n      LENGTH_ENCODE_BYTE_SIZE,\n      byteString.length\n    );\n    if (byteLength !== byteValue.length) {\n      throw new Error(\n        `string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`\n      );\n    }\n    return Buffer.from(byteValue).toString('utf-8');\n  }\n}\n\nexport class ABIArrayStaticType extends ABIType {\n  childType: ABIType;\n  staticLength: number;\n\n  constructor(argType: ABIType, arrayLength: number) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(\n        `static array must have a non negative length: ${arrayLength}`\n      );\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayStaticType &&\n      this.staticLength === other.staticLength &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(\n        `Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`\n      );\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\n\nexport class ABIArrayDynamicType extends ABIType {\n  childType: ABIType;\n\n  constructor(argType: ABIType) {\n    super();\n    this.childType = argType;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayDynamicType &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(\n      convertedTuple.childTypes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(\n      byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length)\n    );\n  }\n\n  toABITupleType(length: number) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\n\nexport class ABITupleType extends ABIType {\n  childTypes: ABIType[];\n\n  constructor(argTypes: ABIType[]) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error(\n        'tuple type child type number larger than maximum uint16 error'\n      );\n    }\n    this.childTypes = argTypes;\n  }\n\n  toString() {\n    const typeStrings: string[] = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABITupleType &&\n      this.childTypes.length === other.childTypes.length &&\n      this.childTypes.every((child, index) =>\n        child.equals(other.childTypes[index])\n      )\n    );\n  }\n\n  isDynamic() {\n    const isDynamic = (child: ABIType) => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads: Uint8Array[] = [];\n    const tails: Uint8Array[] = [];\n    const isDynamicIndex = new Map<number, boolean>();\n    let i = 0;\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error(\n              'expected before index should have number of bool mod 8 equal 0'\n            );\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(\n            values.slice(i, i + after + 1)\n          );\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(\n            `byte length of ${headValue} should not exceed a uint16`\n          );\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n\n    return concatArrays(...heads, ...tails);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments: Segment[] = [];\n    const valuePartition: Uint8Array[] = [];\n    let i = 0;\n    let iterIndex = 0;\n    const buf = Buffer.from(byteString);\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (\n          byteString.slice(iterIndex, byteString.length).length <\n          LENGTH_ENCODE_BYTE_SIZE\n        ) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error(\n              'dynamic index segment miscalculation: left is greater than right index'\n            );\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg: Segment = {\n          left: dynamicIndex,\n          right: -1,\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error(\n          'dynamic segment should display a [l, r] space with l <= r'\n        );\n      }\n      if (\n        j !== dynamicSegments.length - 1 &&\n        seg.right !== dynamicSegments[j + 1].left\n      ) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(\n          dynamicSegments[segIndex].left,\n          dynamicSegments[segIndex].right\n        );\n        segIndex += 1;\n      }\n    }\n\n    // Decode each tuple element\n    const returnValues: ABIValue[] = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n\n  static parseTupleContent(str: string): string[] {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n\n    const tupleStrings: string[] = [];\n    let depth = 0;\n    let word = '';\n\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList: ABIValue[]): number {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << (7 - i);\n    }\n  }\n  return res;\n}\n\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList: ABIType[], index: number, delta: -1 | 1): number {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}