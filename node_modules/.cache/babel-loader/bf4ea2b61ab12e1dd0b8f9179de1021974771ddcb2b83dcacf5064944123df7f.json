{"ast":null,"code":"import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n  const _length = (length || 256) / 8;\n  const bytes = crypto.randomBytes(_length);\n  const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n  return result;\n}\nexport async function verifyHmac(payload, key) {\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const hmac = encoding.hexToArray(payload.hmac);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const chmac = await crypto.hmacSha256Sign(key, unsigned);\n  const chmacHex = encoding.arrayToHex(chmac, false);\n  if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n    return true;\n  }\n  return false;\n}\nexport async function encrypt(data, key, providedIv) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n  const ivArrayBuffer = providedIv || (await generateKey(128));\n  const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n  const ivHex = encoding.arrayToHex(iv, false);\n  const contentString = JSON.stringify(data);\n  const content = encoding.utf8ToArray(contentString);\n  const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n  const cipherTextHex = encoding.arrayToHex(cipherText, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  return {\n    data: cipherTextHex,\n    hmac: hmacHex,\n    iv: ivHex\n  };\n}\nexport async function decrypt(payload, key) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n  if (!_key) {\n    throw new Error(\"Missing key: required for decryption\");\n  }\n  const verified = await verifyHmac(payload, _key);\n  if (!verified) {\n    return null;\n  }\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n  const utf8 = encoding.arrayToUtf8(buffer);\n  let data;\n  try {\n    data = JSON.parse(utf8);\n  } catch (error) {\n    return null;\n  }\n  return data;\n}","map":{"version":3,"names":["crypto","encoding","convertArrayBufferToBuffer","convertBufferToArrayBuffer","generateKey","length","_length","bytes","randomBytes","result","arrayToBuffer","verifyHmac","payload","key","cipherText","hexToArray","data","iv","hmac","hmacHex","arrayToHex","unsigned","concatArrays","chmac","hmacSha256Sign","chmacHex","removeHexPrefix","encrypt","providedIv","_key","bufferToArray","ivArrayBuffer","ivHex","contentString","JSON","stringify","content","utf8ToArray","aesCbcEncrypt","cipherTextHex","decrypt","Error","verified","buffer","aesCbcDecrypt","utf8","arrayToUtf8","parse","error"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}