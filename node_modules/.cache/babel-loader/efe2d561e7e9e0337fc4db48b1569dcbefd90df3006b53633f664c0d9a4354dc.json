{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport Bid from './bid';\nimport * as convert from './convert';\nimport * as utils from './utils/utils';\nvar SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n// Errors\nexport var MULTISIG_BAD_SENDER_ERROR_MSG = 'The transaction sender address and multisig preimage do not match.';\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn - object with either payment or key registration fields\n * @param sk - Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nexport function signTransaction(txn, sk) {\n  if (typeof txn.from === 'undefined') {\n    // Get pk from sk if no sender specified\n    var key = nacl.keyPairFromSecretKey(sk);\n    // eslint-disable-next-line no-param-reassign\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n  var algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return {\n    txID: algoTxn.txID().toString(),\n    blob: algoTxn.signTxn(sk)\n  };\n}\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid - Algorand Bid\n * @param sk - Algorand secret key\n * @returns Uint8Array binary signed bid\n */\nexport function signBid(bid, sk) {\n  var signedBid = new Bid(bid);\n  return signedBid.signBid(sk);\n}\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes - Uint8array\n * @param sk - Algorand secret key\n * @returns binary signature\n */\nexport function signBytes(bytes, sk) {\n  var toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  var sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes - Uint8Array\n * @param signature - binary signature\n * @param addr - string address\n * @returns bool\n */\nexport function verifyBytes(bytes, signature, addr) {\n  var toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  var pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o - js obj\n * @returns Uint8Array binary representation\n */\nexport function encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o - Uint8Array to decode\n * @returns object\n */\nexport function decodeObj(o) {\n  return encoding.decode(o);\n}\nexport var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);\nexport var ERROR_INVALID_MICROALGOS = new Error(convert.INVALID_MICROALGOS_ERROR_MSG);\nexport { default as Algodv2 } from './client/v2/algod/algod';\nexport { default as Kmd } from './client/kmd';\nexport { default as IntDecoding } from './types/intDecoding';\nexport { default as Indexer } from './client/v2/indexer/indexer';\nexport { waitForConfirmation } from './wait';\nexport { isValidAddress, encodeAddress, decodeAddress, getApplicationAddress } from './encoding/address';\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint';\nexport { encodeUint64, decodeUint64 } from './encoding/uint64';\nexport { default as generateAccount } from './account';\nimport * as modelsv2_1 from './client/v2/algod/models/types';\nexport { modelsv2_1 as modelsv2 };\nimport * as indexerModels_1 from './client/v2/indexer/models/types';\nexport { indexerModels_1 as indexerModels };\nexport { mnemonicToMasterDerivationKey, masterDerivationKeyToMnemonic, secretKeyToMnemonic, mnemonicToSecretKey, seedFromMnemonic, mnemonicFromSeed } from './mnemonic/mnemonic';\nexport { microalgosToAlgos, algosToMicroalgos, INVALID_MICROALGOS_ERROR_MSG } from './convert';\nexport { computeGroupID, assignGroupID } from './group';\nexport { LogicSig, LogicSigAccount, signLogicSigTransaction, signLogicSigTransactionObject, logicSigFromByte, tealSign, tealSignFromProgram, verifyTealSign } from './logicsig';\nexport { signMultisigTransaction, mergeMultisigTransactions, appendSignMultisigTransaction, createMultisigTransaction, appendSignRawMultisigSignature, verifyMultisig, multisigAddress } from './multisig';\nexport { SourceMap } from './logic/sourcemap';\nexport * from './dryrun';\nexport * from './makeTxn';\nexport * from './transaction';\nexport * from './signer';\nexport * from './composer';\nexport * from './types';\nexport * from './abi';","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","Bid","convert","utils","SIGN_BYTES_PREFIX","from","MULTISIG_BAD_SENDER_ERROR_MSG","signTransaction","txn","sk","key","keyPairFromSecretKey","encodeAddress","publicKey","algoTxn","instantiateTxnIfNeeded","txID","toString","blob","signTxn","signBid","bid","signedBid","signBytes","bytes","toBeSigned","concatArrays","sig","sign","verifyBytes","signature","addr","toBeVerified","pk","decodeAddress","verify","encodeObj","o","Uint8Array","encode","decodeObj","decode","ERROR_MULTISIG_BAD_SENDER","Error","ERROR_INVALID_MICROALGOS","INVALID_MICROALGOS_ERROR_MSG","default","Algodv2","Kmd","IntDecoding","Indexer","waitForConfirmation","isValidAddress","getApplicationAddress","bytesToBigInt","bigIntToBytes","encodeUint64","decodeUint64","generateAccount","modelsv2","indexerModels","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","secretKeyToMnemonic","mnemonicToSecretKey","seedFromMnemonic","mnemonicFromSeed","microalgosToAlgos","algosToMicroalgos","computeGroupID","assignGroupID","LogicSig","LogicSigAccount","signLogicSigTransaction","signLogicSigTransactionObject","logicSigFromByte","tealSign","tealSignFromProgram","verifyTealSign","signMultisigTransaction","mergeMultisigTransactions","appendSignMultisigTransaction","createMultisigTransaction","appendSignRawMultisigSignature","verifyMultisig","multisigAddress","SourceMap"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/main.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport Bid, { BidOptions } from './bid';\nimport * as convert from './convert';\nimport * as utils from './utils/utils';\n\nconst SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n\n// Errors\nexport const MULTISIG_BAD_SENDER_ERROR_MSG =\n  'The transaction sender address and multisig preimage do not match.';\n\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn - object with either payment or key registration fields\n * @param sk - Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nexport function signTransaction(\n  txn: txnBuilder.TransactionLike,\n  sk: Uint8Array\n) {\n  if (typeof txn.from === 'undefined') {\n    // Get pk from sk if no sender specified\n    const key = nacl.keyPairFromSecretKey(sk);\n    // eslint-disable-next-line no-param-reassign\n    txn.from = address.encodeAddress(key.publicKey);\n  }\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n\n  return {\n    txID: algoTxn.txID().toString(),\n    blob: algoTxn.signTxn(sk),\n  };\n}\n\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid - Algorand Bid\n * @param sk - Algorand secret key\n * @returns Uint8Array binary signed bid\n */\nexport function signBid(bid: BidOptions, sk: Uint8Array) {\n  const signedBid = new Bid(bid);\n  return signedBid.signBid(sk);\n}\n\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes - Uint8array\n * @param sk - Algorand secret key\n * @returns binary signature\n */\nexport function signBytes(bytes: Uint8Array, sk: Uint8Array) {\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes - Uint8Array\n * @param signature - binary signature\n * @param addr - string address\n * @returns bool\n */\nexport function verifyBytes(\n  bytes: Uint8Array,\n  signature: Uint8Array,\n  addr: string\n) {\n  const toBeVerified = Buffer.from(\n    utils.concatArrays(SIGN_BYTES_PREFIX, bytes)\n  );\n  const pk = address.decodeAddress(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o - js obj\n * @returns Uint8Array binary representation\n */\nexport function encodeObj(o: Record<string | number | symbol, any>) {\n  return new Uint8Array(encoding.encode(o));\n}\n\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o - Uint8Array to decode\n * @returns object\n */\nexport function decodeObj(o: ArrayLike<number>) {\n  return encoding.decode(o);\n}\n\nexport const ERROR_MULTISIG_BAD_SENDER = new Error(\n  MULTISIG_BAD_SENDER_ERROR_MSG\n);\nexport const ERROR_INVALID_MICROALGOS = new Error(\n  convert.INVALID_MICROALGOS_ERROR_MSG\n);\n\nexport { default as Algodv2 } from './client/v2/algod/algod';\nexport { default as Kmd } from './client/kmd';\nexport { default as IntDecoding } from './types/intDecoding';\nexport { default as Account } from './types/account';\nexport { default as Indexer } from './client/v2/indexer/indexer';\nexport {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  BaseHTTPClientError,\n} from './client/baseHTTPClient';\nexport {\n  AlgodTokenHeader,\n  IndexerTokenHeader,\n  KMDTokenHeader,\n  CustomTokenHeader,\n  TokenHeader,\n} from './client/urlTokenBaseHTTPClient';\nexport { waitForConfirmation } from './wait';\nexport {\n  isValidAddress,\n  encodeAddress,\n  decodeAddress,\n  getApplicationAddress,\n} from './encoding/address';\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint';\nexport { encodeUint64, decodeUint64 } from './encoding/uint64';\nexport { default as generateAccount } from './account';\nexport * as modelsv2 from './client/v2/algod/models/types';\nexport * as indexerModels from './client/v2/indexer/models/types';\nexport {\n  mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic,\n  secretKeyToMnemonic,\n  mnemonicToSecretKey,\n  seedFromMnemonic,\n  mnemonicFromSeed,\n} from './mnemonic/mnemonic';\nexport {\n  microalgosToAlgos,\n  algosToMicroalgos,\n  INVALID_MICROALGOS_ERROR_MSG,\n} from './convert';\nexport { computeGroupID, assignGroupID } from './group';\nexport {\n  LogicSig,\n  LogicSigAccount,\n  signLogicSigTransaction,\n  signLogicSigTransactionObject,\n  logicSigFromByte,\n  tealSign,\n  tealSignFromProgram,\n  verifyTealSign,\n} from './logicsig';\nexport {\n  signMultisigTransaction,\n  mergeMultisigTransactions,\n  appendSignMultisigTransaction,\n  createMultisigTransaction,\n  appendSignRawMultisigSignature,\n  verifyMultisig,\n  multisigAddress,\n} from './multisig';\nexport { SourceMap } from './logic/sourcemap';\n\nexport * from './dryrun';\nexport * from './makeTxn';\nexport * from './transaction';\nexport * from './signer';\nexport * from './composer';\nexport * from './types';\nexport * from './abi';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}