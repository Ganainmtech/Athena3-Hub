{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { genericHash } from '../nacl/naclWrappers';\nimport { ABIType, ABITupleType } from './abi_type';\nimport { abiTypeIsTransaction } from './transaction';\nimport { abiTypeIsReference } from './reference';\nfunction parseMethodSignature(signature) {\n  var argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(\"Invalid method signature: \".concat(signature));\n  }\n  var argsEnd = -1;\n  var depth = 0;\n  for (var i = argsStart; i < signature.length; i++) {\n    var char = signature[i];\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n  if (argsEnd === -1) {\n    throw new Error(\"Invalid method signature: \".concat(signature));\n  }\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),\n    returns: signature.slice(argsEnd + 1)\n  };\n}\nexport var ABIMethod = /*#__PURE__*/function () {\n  function ABIMethod(params) {\n    _classCallCheck(this, ABIMethod);\n    if (typeof params.name !== 'string' || typeof params.returns !== 'object' || !Array.isArray(params.args)) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(function (_ref) {\n      var type = _ref.type,\n        name = _ref.name,\n        desc = _ref.desc;\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type: type,\n          name: name,\n          description: desc\n        };\n      }\n      return {\n        type: ABIType.from(type),\n        name: name,\n        description: desc\n      };\n    });\n    this.returns = {\n      type: params.returns.type === 'void' ? params.returns.type : ABIType.from(params.returns.type),\n      description: params.returns.desc\n    };\n  }\n  _createClass(ABIMethod, [{\n    key: \"getSignature\",\n    value: function getSignature() {\n      var args = this.args.map(function (arg) {\n        return arg.type.toString();\n      }).join(',');\n      var returns = this.returns.type.toString();\n      return \"\".concat(this.name, \"(\").concat(args, \")\").concat(returns);\n    }\n  }, {\n    key: \"getSelector\",\n    value: function getSelector() {\n      var hash = genericHash(this.getSignature());\n      return new Uint8Array(hash.slice(0, 4));\n    }\n  }, {\n    key: \"txnCount\",\n    value: function txnCount() {\n      var count = 1;\n      var _iterator = _createForOfIteratorHelper(this.args),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var arg = _step.value;\n          if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n            count += 1;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return count;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        desc: this.description,\n        args: this.args.map(function (_ref2) {\n          var type = _ref2.type,\n            name = _ref2.name,\n            description = _ref2.description;\n          return {\n            type: type.toString(),\n            name: name,\n            desc: description\n          };\n        }),\n        returns: {\n          type: this.returns.type.toString(),\n          desc: this.returns.description\n        }\n      };\n    }\n  }], [{\n    key: \"fromSignature\",\n    value: function fromSignature(signature) {\n      var _parseMethodSignature = parseMethodSignature(signature),\n        name = _parseMethodSignature.name,\n        args = _parseMethodSignature.args,\n        returns = _parseMethodSignature.returns;\n      return new ABIMethod({\n        name: name,\n        args: args.map(function (arg) {\n          return {\n            type: arg\n          };\n        }),\n        returns: {\n          type: returns\n        }\n      });\n    }\n  }]);\n  return ABIMethod;\n}();\nexport function getMethodByName(methods, name) {\n  if (methods === null || !Array.isArray(methods) || !methods.every(function (item) {\n    return item instanceof ABIMethod;\n  })) throw new Error('Methods list provided is null or not the correct type');\n  var filteredMethods = methods.filter(function (m) {\n    return m.name === name;\n  });\n  if (filteredMethods.length > 1) throw new Error(\"found \".concat(filteredMethods.length, \" methods with the same name \").concat(filteredMethods.map(function (m) {\n    return m.getSignature();\n  }).join(',')));\n  if (filteredMethods.length === 0) throw new Error(\"found 0 methods with the name \".concat(name));\n  return filteredMethods[0];\n}","map":{"version":3,"names":["genericHash","ABIType","ABITupleType","abiTypeIsTransaction","abiTypeIsReference","parseMethodSignature","signature","argsStart","indexOf","Error","concat","argsEnd","depth","i","length","char","name","slice","args","parseTupleContent","returns","ABIMethod","params","_classCallCheck","Array","isArray","description","desc","map","_ref","type","from","_createClass","key","value","getSignature","arg","toString","join","getSelector","hash","Uint8Array","txnCount","count","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","toJSON","_ref2","fromSignature","_parseMethodSignature","getMethodByName","methods","every","item","filteredMethods","filter","m"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/abi/method.ts"],"sourcesContent":["import { genericHash } from '../nacl/naclWrappers';\nimport { ABIType, ABITupleType } from './abi_type';\nimport { ABITransactionType, abiTypeIsTransaction } from './transaction';\nimport { ABIReferenceType, abiTypeIsReference } from './reference';\n\nfunction parseMethodSignature(\n  signature: string\n): { name: string; args: string[]; returns: string } {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n\n  if (argsEnd === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(\n      signature.slice(argsStart + 1, argsEnd)\n    ),\n    returns: signature.slice(argsEnd + 1),\n  };\n}\n\nexport interface ABIMethodArgParams {\n  type: string;\n  name?: string;\n  desc?: string;\n}\n\nexport interface ABIMethodReturnParams {\n  type: string;\n  desc?: string;\n}\n\nexport interface ABIMethodParams {\n  name: string;\n  desc?: string;\n  args: ABIMethodArgParams[];\n  returns: ABIMethodReturnParams;\n}\n\nexport type ABIArgumentType = ABIType | ABITransactionType | ABIReferenceType;\n\nexport type ABIReturnType = ABIType | 'void';\n\nexport class ABIMethod {\n  public readonly name: string;\n  public readonly description?: string;\n  public readonly args: Array<{\n    type: ABIArgumentType;\n    name?: string;\n    description?: string;\n  }>;\n\n  public readonly returns: { type: ABIReturnType; description?: string };\n\n  constructor(params: ABIMethodParams) {\n    if (\n      typeof params.name !== 'string' ||\n      typeof params.returns !== 'object' ||\n      !Array.isArray(params.args)\n    ) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(({ type, name, desc }) => {\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc,\n        };\n      }\n\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc,\n      };\n    });\n    this.returns = {\n      type:\n        params.returns.type === 'void'\n          ? params.returns.type\n          : ABIType.from(params.returns.type),\n      description: params.returns.desc,\n    };\n  }\n\n  getSignature(): string {\n    const args = this.args.map((arg) => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return `${this.name}(${args})${returns}`;\n  }\n\n  getSelector(): Uint8Array {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n\n  txnCount(): number {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  toJSON(): ABIMethodParams {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(({ type, name, description }) => ({\n        type: type.toString(),\n        name,\n        desc: description,\n      })),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description,\n      },\n    };\n  }\n\n  static fromSignature(signature: string): ABIMethod {\n    const { name, args, returns } = parseMethodSignature(signature);\n\n    return new ABIMethod({\n      name,\n      args: args.map((arg) => ({ type: arg })),\n      returns: { type: returns },\n    });\n  }\n}\n\nexport function getMethodByName(methods: ABIMethod[], name: string): ABIMethod {\n  if (\n    methods === null ||\n    !Array.isArray(methods) ||\n    !methods.every((item) => item instanceof ABIMethod)\n  )\n    throw new Error('Methods list provided is null or not the correct type');\n\n  const filteredMethods = methods.filter((m: ABIMethod) => m.name === name);\n  if (filteredMethods.length > 1)\n    throw new Error(\n      `found ${\n        filteredMethods.length\n      } methods with the same name ${filteredMethods\n        .map((m: ABIMethod) => m.getSignature())\n        .join(',')}`\n    );\n\n  if (filteredMethods.length === 0)\n    throw new Error(`found 0 methods with the name ${name}`);\n\n  return filteredMethods[0];\n}\n"],"mappings":";;;AAAA,SAASA,WAAW,QAAQ,sBAAsB;AAClD,SAASC,OAAO,EAAEC,YAAY,QAAQ,YAAY;AAClD,SAA6BC,oBAAoB,QAAQ,eAAe;AACxE,SAA2BC,kBAAkB,QAAQ,aAAa;AAElE,SAASC,oBAAoBA,CAC3BC,SAAiB;EAEjB,IAAMC,SAAS,GAAGD,SAAS,CAACE,OAAO,CAAC,GAAG,CAAC;EACxC,IAAID,SAAS,KAAK,CAAC,CAAC,EAAE;IACpB,MAAM,IAAIE,KAAK,8BAAAC,MAAA,CAA8BJ,SAAS,CAAE,CAAC;;EAG3D,IAAIK,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIC,KAAK,GAAG,CAAC;EACb,KAAK,IAAIC,CAAC,GAAGN,SAAS,EAAEM,CAAC,GAAGP,SAAS,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACjD,IAAME,IAAI,GAAGT,SAAS,CAACO,CAAC,CAAC;IAEzB,IAAIE,IAAI,KAAK,GAAG,EAAE;MAChBH,KAAK,IAAI,CAAC;KACX,MAAM,IAAIG,IAAI,KAAK,GAAG,EAAE;MACvB,IAAIH,KAAK,KAAK,CAAC,EAAE;QACf;QACA;;MAGFA,KAAK,IAAI,CAAC;MACV,IAAIA,KAAK,KAAK,CAAC,EAAE;QACfD,OAAO,GAAGE,CAAC;QACX;;;;EAKN,IAAIF,OAAO,KAAK,CAAC,CAAC,EAAE;IAClB,MAAM,IAAIF,KAAK,8BAAAC,MAAA,CAA8BJ,SAAS,CAAE,CAAC;;EAG3D,OAAO;IACLU,IAAI,EAAEV,SAAS,CAACW,KAAK,CAAC,CAAC,EAAEV,SAAS,CAAC;IACnCW,IAAI,EAAEhB,YAAY,CAACiB,iBAAiB,CAClCb,SAAS,CAACW,KAAK,CAACV,SAAS,GAAG,CAAC,EAAEI,OAAO,CAAC,CACxC;IACDS,OAAO,EAAEd,SAAS,CAACW,KAAK,CAACN,OAAO,GAAG,CAAC;GACrC;AACH;AAwBA,WAAaU,SAAS;EAWpB,SAAAA,UAAYC,MAAuB;IAAAC,eAAA,OAAAF,SAAA;IACjC,IACE,OAAOC,MAAM,CAACN,IAAI,KAAK,QAAQ,IAC/B,OAAOM,MAAM,CAACF,OAAO,KAAK,QAAQ,IAClC,CAACI,KAAK,CAACC,OAAO,CAACH,MAAM,CAACJ,IAAI,CAAC,EAC3B;MACA,MAAM,IAAIT,KAAK,CAAC,8BAA8B,CAAC;;IAGjD,IAAI,CAACO,IAAI,GAAGM,MAAM,CAACN,IAAI;IACvB,IAAI,CAACU,WAAW,GAAGJ,MAAM,CAACK,IAAI;IAC9B,IAAI,CAACT,IAAI,GAAGI,MAAM,CAACJ,IAAI,CAACU,GAAG,CAAC,UAAAC,IAAA,EAAyB;MAAA,IAAtBC,IAAI,GAAAD,IAAA,CAAJC,IAAI;QAAEd,IAAI,GAAAa,IAAA,CAAJb,IAAI;QAAEW,IAAI,GAAAE,IAAA,CAAJF,IAAI;MAC7C,IAAIxB,oBAAoB,CAAC2B,IAAI,CAAC,IAAI1B,kBAAkB,CAAC0B,IAAI,CAAC,EAAE;QAC1D,OAAO;UACLA,IAAI,EAAJA,IAAI;UACJd,IAAI,EAAJA,IAAI;UACJU,WAAW,EAAEC;SACd;;MAGH,OAAO;QACLG,IAAI,EAAE7B,OAAO,CAAC8B,IAAI,CAACD,IAAI,CAAC;QACxBd,IAAI,EAAJA,IAAI;QACJU,WAAW,EAAEC;OACd;IACH,CAAC,CAAC;IACF,IAAI,CAACP,OAAO,GAAG;MACbU,IAAI,EACFR,MAAM,CAACF,OAAO,CAACU,IAAI,KAAK,MAAM,GAC1BR,MAAM,CAACF,OAAO,CAACU,IAAI,GACnB7B,OAAO,CAAC8B,IAAI,CAACT,MAAM,CAACF,OAAO,CAACU,IAAI,CAAC;MACvCJ,WAAW,EAAEJ,MAAM,CAACF,OAAO,CAACO;KAC7B;EACH;EAACK,YAAA,CAAAX,SAAA;IAAAY,GAAA;IAAAC,KAAA,EAED,SAAAC,aAAA,EAAY;MACV,IAAMjB,IAAI,GAAG,IAAI,CAACA,IAAI,CAACU,GAAG,CAAC,UAACQ,GAAG;QAAA,OAAKA,GAAG,CAACN,IAAI,CAACO,QAAQ,EAAE;MAAA,EAAC,CAACC,IAAI,CAAC,GAAG,CAAC;MAClE,IAAMlB,OAAO,GAAG,IAAI,CAACA,OAAO,CAACU,IAAI,CAACO,QAAQ,EAAE;MAC5C,UAAA3B,MAAA,CAAU,IAAI,CAACM,IAAI,OAAAN,MAAA,CAAIQ,IAAI,OAAAR,MAAA,CAAIU,OAAO;IACxC;EAAC;IAAAa,GAAA;IAAAC,KAAA,EAED,SAAAK,YAAA,EAAW;MACT,IAAMC,IAAI,GAAGxC,WAAW,CAAC,IAAI,CAACmC,YAAY,EAAE,CAAC;MAC7C,OAAO,IAAIM,UAAU,CAACD,IAAI,CAACvB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACzC;EAAC;IAAAgB,GAAA;IAAAC,KAAA,EAED,SAAAQ,SAAA,EAAQ;MACN,IAAIC,KAAK,GAAG,CAAC;MAAC,IAAAC,SAAA,GAAAC,0BAAA,CACI,IAAI,CAAC3B,IAAI;QAAA4B,KAAA;MAAA;QAA3B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA6B;UAAA,IAAlBb,GAAG,GAAAU,KAAA,CAAAZ,KAAA;UACZ,IAAI,OAAOE,GAAG,CAACN,IAAI,KAAK,QAAQ,IAAI3B,oBAAoB,CAACiC,GAAG,CAACN,IAAI,CAAC,EAAE;YAClEa,KAAK,IAAI,CAAC;;;MAEb,SAAAO,GAAA;QAAAN,SAAA,CAAAO,CAAA,CAAAD,GAAA;MAAA;QAAAN,SAAA,CAAAQ,CAAA;MAAA;MACD,OAAOT,KAAK;IACd;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAED,SAAAmB,OAAA,EAAM;MACJ,OAAO;QACLrC,IAAI,EAAE,IAAI,CAACA,IAAI;QACfW,IAAI,EAAE,IAAI,CAACD,WAAW;QACtBR,IAAI,EAAE,IAAI,CAACA,IAAI,CAACU,GAAG,CAAC,UAAA0B,KAAA;UAAA,IAAGxB,IAAI,GAAAwB,KAAA,CAAJxB,IAAI;YAAEd,IAAI,GAAAsC,KAAA,CAAJtC,IAAI;YAAEU,WAAW,GAAA4B,KAAA,CAAX5B,WAAW;UAAA,OAAQ;YACpDI,IAAI,EAAEA,IAAI,CAACO,QAAQ,EAAE;YACrBrB,IAAI,EAAJA,IAAI;YACJW,IAAI,EAAED;WACP;QAAA,CAAC,CAAC;QACHN,OAAO,EAAE;UACPU,IAAI,EAAE,IAAI,CAACV,OAAO,CAACU,IAAI,CAACO,QAAQ,EAAE;UAClCV,IAAI,EAAE,IAAI,CAACP,OAAO,CAACM;;OAEtB;IACH;EAAC;IAAAO,GAAA;IAAAC,KAAA,EAED,SAAAqB,cAAqBjD,SAAiB;MACpC,IAAAkD,qBAAA,GAAgCnD,oBAAoB,CAACC,SAAS,CAAC;QAAvDU,IAAI,GAAAwC,qBAAA,CAAJxC,IAAI;QAAEE,IAAI,GAAAsC,qBAAA,CAAJtC,IAAI;QAAEE,OAAO,GAAAoC,qBAAA,CAAPpC,OAAO;MAE3B,OAAO,IAAIC,SAAS,CAAC;QACnBL,IAAI,EAAJA,IAAI;QACJE,IAAI,EAAEA,IAAI,CAACU,GAAG,CAAC,UAACQ,GAAG;UAAA,OAAM;YAAEN,IAAI,EAAEM;UAAG,CAAE;QAAA,CAAC,CAAC;QACxChB,OAAO,EAAE;UAAEU,IAAI,EAAEV;QAAO;OACzB,CAAC;IACJ;EAAC;EAAA,OAAAC,SAAA;AAAA;AAGH,OAAM,SAAUoC,eAAeA,CAACC,OAAoB,EAAE1C,IAAY;EAChE,IACE0C,OAAO,KAAK,IAAI,IAChB,CAAClC,KAAK,CAACC,OAAO,CAACiC,OAAO,CAAC,IACvB,CAACA,OAAO,CAACC,KAAK,CAAC,UAACC,IAAI;IAAA,OAAKA,IAAI,YAAYvC,SAAS;EAAA,EAAC,EAEnD,MAAM,IAAIZ,KAAK,CAAC,uDAAuD,CAAC;EAE1E,IAAMoD,eAAe,GAAGH,OAAO,CAACI,MAAM,CAAC,UAACC,CAAY;IAAA,OAAKA,CAAC,CAAC/C,IAAI,KAAKA,IAAI;EAAA,EAAC;EACzE,IAAI6C,eAAe,CAAC/C,MAAM,GAAG,CAAC,EAC5B,MAAM,IAAIL,KAAK,UAAAC,MAAA,CAEXmD,eAAe,CAAC/C,MAClB,kCAAAJ,MAAA,CAA+BmD,eAAe,CAC3CjC,GAAG,CAAC,UAACmC,CAAY;IAAA,OAAKA,CAAC,CAAC5B,YAAY,EAAE;EAAA,EAAC,CACvCG,IAAI,CAAC,GAAG,CAAC,CAAE,CACf;EAEH,IAAIuB,eAAe,CAAC/C,MAAM,KAAK,CAAC,EAC9B,MAAM,IAAIL,KAAK,kCAAAC,MAAA,CAAkCM,IAAI,CAAE,CAAC;EAE1D,OAAO6C,eAAe,CAAC,CAAC,CAAC;AAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}