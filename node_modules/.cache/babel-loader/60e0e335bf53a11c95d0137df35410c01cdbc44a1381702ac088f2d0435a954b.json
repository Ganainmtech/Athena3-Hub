{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { Buffer } from 'buffer';\nimport { encodeAddress, decodeAddress } from '../encoding/address';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint';\nimport { concatArrays } from '../utils/utils';\nexport var MAX_LEN = Math.pow(2, 16) - 1;\nexport var ADDR_BYTE_SIZE = 32;\nexport var SINGLE_BYTE_SIZE = 1;\nexport var SINGLE_BOOL_SIZE = 1;\nexport var LENGTH_ENCODE_BYTE_SIZE = 2;\nvar staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nvar ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\nexport var ABIType = /*#__PURE__*/function () {\n  function ABIType() {\n    _classCallCheck(this, ABIType);\n  }\n  _createClass(ABIType, null, [{\n    key: \"from\",\n    value:\n    // De-serializes the ABI type from a string using the ABI specs\n    function from(str) {\n      if (str.endsWith('[]')) {\n        var arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n        return new ABIArrayDynamicType(arrayArgType);\n      }\n      if (str.endsWith(']')) {\n        var stringMatches = str.match(staticArrayRegexp);\n        // Match the string itself, array element type, then array length\n        if (stringMatches.length !== 3) {\n          throw new Error(\"malformed static array string: \".concat(str));\n        }\n        // Parse static array using regex\n        var arrayLengthStr = stringMatches[2];\n        var arrayLength = parseInt(arrayLengthStr, 10);\n        if (arrayLength > MAX_LEN) {\n          throw new Error(\"array length exceeds limit \".concat(MAX_LEN));\n        }\n        // Parse the array element type\n        var arrayType = ABIType.from(stringMatches[1]);\n        return new ABIArrayStaticType(arrayType, arrayLength);\n      }\n      if (str.startsWith('uint')) {\n        // Checks if the parsed number contains only digits, no whitespaces\n        var digitsOnly = function digitsOnly(string) {\n          return _toConsumableArray(string).every(function (c) {\n            return '0123456789'.includes(c);\n          });\n        };\n        var typeSizeStr = str.slice(4, str.length);\n        if (!digitsOnly(typeSizeStr)) {\n          throw new Error(\"malformed uint string: \".concat(typeSizeStr));\n        }\n        var typeSize = parseInt(typeSizeStr, 10);\n        if (typeSize > MAX_LEN) {\n          throw new Error(\"malformed uint string: \".concat(typeSize));\n        }\n        return new ABIUintType(typeSize);\n      }\n      if (str === 'byte') {\n        return new ABIByteType();\n      }\n      if (str.startsWith('ufixed')) {\n        var _stringMatches = str.match(ufixedRegexp);\n        if (_stringMatches.length !== 3) {\n          throw new Error(\"malformed ufixed type: \".concat(str));\n        }\n        var ufixedSize = parseInt(_stringMatches[1], 10);\n        var ufixedPrecision = parseInt(_stringMatches[2], 10);\n        return new ABIUfixedType(ufixedSize, ufixedPrecision);\n      }\n      if (str === 'bool') {\n        return new ABIBoolType();\n      }\n      if (str === 'address') {\n        return new ABIAddressType();\n      }\n      if (str === 'string') {\n        return new ABIStringType();\n      }\n      if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n        var tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));\n        var tupleTypes = [];\n        for (var i = 0; i < tupleContent.length; i++) {\n          var ti = ABIType.from(tupleContent[i]);\n          tupleTypes.push(ti);\n        }\n        return new ABITupleType(tupleTypes);\n      }\n      throw new Error(\"cannot convert a string \".concat(str, \" to an ABI type\"));\n    }\n  }]);\n  return ABIType;\n}();\nexport var ABIUintType = /*#__PURE__*/function (_ABIType) {\n  _inherits(ABIUintType, _ABIType);\n  var _super = _createSuper(ABIUintType);\n  function ABIUintType(size) {\n    var _this;\n    _classCallCheck(this, ABIUintType);\n    _this = _super.call(this);\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(\"unsupported uint type bitSize: \".concat(size));\n    }\n    _this.bitSize = size;\n    return _this;\n  }\n  _createClass(ABIUintType, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"uint\".concat(this.bitSize);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIUintType && this.bitSize === other.bitSize;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return false;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      return this.bitSize / 8;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'bigint' && typeof value !== 'number') {\n        throw new Error(\"Cannot encode value as uint\".concat(this.bitSize, \": \").concat(value));\n      }\n      if (value >= BigInt(Math.pow(2, this.bitSize)) || value < BigInt(0)) {\n        throw new Error(\"\".concat(value, \" is not a non-negative int or too big to fit in size uint\").concat(this.bitSize));\n      }\n      if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n        throw new Error(\"\".concat(value, \" should be converted into a BigInt before it is encoded\"));\n      }\n      return bigIntToBytes(value, this.bitSize / 8);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.length !== this.bitSize / 8) {\n        throw new Error(\"byte string must correspond to a uint\".concat(this.bitSize));\n      }\n      return bytesToBigInt(byteString);\n    }\n  }]);\n  return ABIUintType;\n}(ABIType);\nexport var ABIUfixedType = /*#__PURE__*/function (_ABIType2) {\n  _inherits(ABIUfixedType, _ABIType2);\n  var _super2 = _createSuper(ABIUfixedType);\n  function ABIUfixedType(size, denominator) {\n    var _this2;\n    _classCallCheck(this, ABIUfixedType);\n    _this2 = _super2.call(this);\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(\"unsupported ufixed type bitSize: \".concat(size));\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(\"unsupported ufixed type precision: \".concat(denominator));\n    }\n    _this2.bitSize = size;\n    _this2.precision = denominator;\n    return _this2;\n  }\n  _createClass(ABIUfixedType, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ufixed\".concat(this.bitSize, \"x\").concat(this.precision);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return false;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      return this.bitSize / 8;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'bigint' && typeof value !== 'number') {\n        throw new Error(\"Cannot encode value as \".concat(this.toString(), \": \").concat(value));\n      }\n      if (value >= BigInt(Math.pow(2, this.bitSize)) || value < BigInt(0)) {\n        throw new Error(\"\".concat(value, \" is not a non-negative int or too big to fit in size \").concat(this.toString()));\n      }\n      if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n        throw new Error(\"\".concat(value, \" should be converted into a BigInt before it is encoded\"));\n      }\n      return bigIntToBytes(value, this.bitSize / 8);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.length !== this.bitSize / 8) {\n        throw new Error(\"byte string must correspond to a \".concat(this.toString()));\n      }\n      return bytesToBigInt(byteString);\n    }\n  }]);\n  return ABIUfixedType;\n}(ABIType);\nexport var ABIAddressType = /*#__PURE__*/function (_ABIType3) {\n  _inherits(ABIAddressType, _ABIType3);\n  var _super3 = _createSuper(ABIAddressType);\n  function ABIAddressType() {\n    _classCallCheck(this, ABIAddressType);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(ABIAddressType, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'address';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIAddressType;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return false;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      return ADDR_BYTE_SIZE;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n        throw new Error(\"Cannot encode value as \".concat(this.toString(), \": \").concat(value));\n      }\n      if (typeof value === 'string') {\n        var decodedAddress = decodeAddress(value);\n        return decodedAddress.publicKey;\n      }\n      // Return the address if it is already in bytes\n      if (value.byteLength !== 32) {\n        throw new Error(\"byte string must be 32 bytes long for an address\");\n      }\n      return value;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.byteLength !== 32) {\n        throw new Error(\"byte string must be 32 bytes long for an address\");\n      }\n      return encodeAddress(byteString);\n    }\n  }]);\n  return ABIAddressType;\n}(ABIType);\nexport var ABIBoolType = /*#__PURE__*/function (_ABIType4) {\n  _inherits(ABIBoolType, _ABIType4);\n  var _super4 = _createSuper(ABIBoolType);\n  function ABIBoolType() {\n    _classCallCheck(this, ABIBoolType);\n    return _super4.apply(this, arguments);\n  }\n  _createClass(ABIBoolType, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'bool';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIBoolType;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return false;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      return SINGLE_BOOL_SIZE;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'boolean') {\n        throw new Error(\"Cannot encode value as bool: \".concat(value));\n      }\n      if (value) {\n        return new Uint8Array([128]);\n      }\n      return new Uint8Array([0]);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.byteLength !== 1) {\n        throw new Error(\"bool string must be 1 byte long\");\n      }\n      var value = byteString[0];\n      if (value === 128) {\n        return true;\n      }\n      if (value === 0) {\n        return false;\n      }\n      throw new Error(\"boolean could not be decoded from the byte string\");\n    }\n  }]);\n  return ABIBoolType;\n}(ABIType);\nexport var ABIByteType = /*#__PURE__*/function (_ABIType5) {\n  _inherits(ABIByteType, _ABIType5);\n  var _super5 = _createSuper(ABIByteType);\n  function ABIByteType() {\n    _classCallCheck(this, ABIByteType);\n    return _super5.apply(this, arguments);\n  }\n  _createClass(ABIByteType, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'byte';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIByteType;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return false;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      return SINGLE_BYTE_SIZE;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'number' && typeof value !== 'bigint') {\n        throw new Error(\"Cannot encode value as byte: \".concat(value));\n      }\n      if (typeof value === 'bigint') {\n        // eslint-disable-next-line no-param-reassign\n        value = Number(value);\n      }\n      if (value < 0 || value > 255) {\n        throw new Error(\"\".concat(value, \" cannot be encoded into a byte\"));\n      }\n      return new Uint8Array([value]);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.byteLength !== 1) {\n        throw new Error(\"byte string must be 1 byte long\");\n      }\n      return byteString[0];\n    }\n  }]);\n  return ABIByteType;\n}(ABIType);\nexport var ABIStringType = /*#__PURE__*/function (_ABIType6) {\n  _inherits(ABIStringType, _ABIType6);\n  var _super6 = _createSuper(ABIStringType);\n  function ABIStringType() {\n    _classCallCheck(this, ABIStringType);\n    return _super6.apply(this, arguments);\n  }\n  _createClass(ABIStringType, [{\n    key: \"toString\",\n    value: function toString() {\n      return 'string';\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIStringType;\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return true;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      throw new Error(\"\".concat(this.toString(), \" is a dynamic type\"));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n        throw new Error(\"Cannot encode value as string: \".concat(value));\n      }\n      var encodedBytes = Buffer.from(value);\n      var encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);\n      var mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);\n      mergedBytes.set(encodedLength);\n      mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n      return mergedBytes;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n        throw new Error(\"byte string is too short to be decoded. Actual length is \".concat(byteString.length, \", but expected at least \").concat(LENGTH_ENCODE_BYTE_SIZE));\n      }\n      var buf = Buffer.from(byteString);\n      var byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n      var byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);\n      if (byteLength !== byteValue.length) {\n        throw new Error(\"string length bytes do not match the actual length of string. Expected \".concat(byteLength, \", got \").concat(byteValue.length));\n      }\n      return Buffer.from(byteValue).toString('utf-8');\n    }\n  }]);\n  return ABIStringType;\n}(ABIType);\nexport var ABIArrayStaticType = /*#__PURE__*/function (_ABIType7) {\n  _inherits(ABIArrayStaticType, _ABIType7);\n  var _super7 = _createSuper(ABIArrayStaticType);\n  function ABIArrayStaticType(argType, arrayLength) {\n    var _this3;\n    _classCallCheck(this, ABIArrayStaticType);\n    _this3 = _super7.call(this);\n    if (arrayLength < 0) {\n      throw new Error(\"static array must have a non negative length: \".concat(arrayLength));\n    }\n    _this3.childType = argType;\n    _this3.staticLength = arrayLength;\n    return _this3;\n  }\n  _createClass(ABIArrayStaticType, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.childType.toString(), \"[\").concat(this.staticLength, \"]\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return this.childType.isDynamic();\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      if (this.childType.constructor === ABIBoolType) {\n        return Math.ceil(this.staticLength / 8);\n      }\n      return this.staticLength * this.childType.byteLen();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n        throw new Error(\"Cannot encode value as \".concat(this.toString(), \": \").concat(value));\n      }\n      if (value.length !== this.staticLength) {\n        throw new Error(\"Value array does not match static array length. Expected \".concat(this.staticLength, \", got \").concat(value.length));\n      }\n      var convertedTuple = this.toABITupleType();\n      return convertedTuple.encode(value);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      var convertedTuple = this.toABITupleType();\n      return convertedTuple.decode(byteString);\n    }\n  }, {\n    key: \"toABITupleType\",\n    value: function toABITupleType() {\n      return new ABITupleType(Array(this.staticLength).fill(this.childType));\n    }\n  }]);\n  return ABIArrayStaticType;\n}(ABIType);\nexport var ABIArrayDynamicType = /*#__PURE__*/function (_ABIType8) {\n  _inherits(ABIArrayDynamicType, _ABIType8);\n  var _super8 = _createSuper(ABIArrayDynamicType);\n  function ABIArrayDynamicType(argType) {\n    var _this4;\n    _classCallCheck(this, ABIArrayDynamicType);\n    _this4 = _super8.call(this);\n    _this4.childType = argType;\n    return _this4;\n  }\n  _createClass(ABIArrayDynamicType, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.childType.toString(), \"[]\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      return true;\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      throw new Error(\"\".concat(this.toString(), \" is a dynamic type\"));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n        throw new Error(\"Cannot encode value as \".concat(this.toString(), \": \").concat(value));\n      }\n      var convertedTuple = this.toABITupleType(value.length);\n      var encodedTuple = convertedTuple.encode(value);\n      var encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);\n      var mergedBytes = concatArrays(encodedLength, encodedTuple);\n      return mergedBytes;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      var buf = Buffer.from(byteString);\n      var byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n      var convertedTuple = this.toABITupleType(byteLength);\n      return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));\n    }\n  }, {\n    key: \"toABITupleType\",\n    value: function toABITupleType(length) {\n      return new ABITupleType(Array(length).fill(this.childType));\n    }\n  }]);\n  return ABIArrayDynamicType;\n}(ABIType);\nexport var ABITupleType = /*#__PURE__*/function (_ABIType9) {\n  _inherits(ABITupleType, _ABIType9);\n  var _super9 = _createSuper(ABITupleType);\n  function ABITupleType(argTypes) {\n    var _this5;\n    _classCallCheck(this, ABITupleType);\n    _this5 = _super9.call(this);\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error('tuple type child type number larger than maximum uint16 error');\n    }\n    _this5.childTypes = argTypes;\n    return _this5;\n  }\n  _createClass(ABITupleType, [{\n    key: \"toString\",\n    value: function toString() {\n      var typeStrings = [];\n      for (var i = 0; i < this.childTypes.length; i++) {\n        typeStrings[i] = this.childTypes[i].toString();\n      }\n      return \"(\".concat(typeStrings.join(','), \")\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every(function (child, index) {\n        return child.equals(other.childTypes[index]);\n      });\n    }\n  }, {\n    key: \"isDynamic\",\n    value: function isDynamic() {\n      var isDynamic = function isDynamic(child) {\n        return child.isDynamic();\n      };\n      return this.childTypes.some(isDynamic);\n    }\n  }, {\n    key: \"byteLen\",\n    value: function byteLen() {\n      var size = 0;\n      for (var i = 0; i < this.childTypes.length; i++) {\n        if (this.childTypes[i].constructor === ABIBoolType) {\n          var after = findBoolLR(this.childTypes, i, 1);\n          var boolNum = after + 1;\n          i += after;\n          size += Math.trunc((boolNum + 7) / 8);\n        } else {\n          var childByteSize = this.childTypes[i].byteLen();\n          size += childByteSize;\n        }\n      }\n      return size;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n        throw new Error(\"Cannot encode value as \".concat(this.toString(), \": \").concat(value));\n      }\n      var values = Array.from(value);\n      if (value.length > MAX_LEN) {\n        throw new Error('length of tuple array should not exceed a uint16');\n      }\n      var tupleTypes = this.childTypes;\n      var heads = [];\n      var tails = [];\n      var isDynamicIndex = new Map();\n      var i = 0;\n      while (i < tupleTypes.length) {\n        var tupleType = tupleTypes[i];\n        if (tupleType.isDynamic()) {\n          // Head is not pre-determined for dynamic types; store a placeholder for now\n          isDynamicIndex.set(heads.length, true);\n          heads.push(new Uint8Array([0, 0]));\n          tails.push(tupleType.encode(values[i]));\n        } else {\n          if (tupleType.constructor === ABIBoolType) {\n            var before = findBoolLR(tupleTypes, i, -1);\n            var after = findBoolLR(tupleTypes, i, 1);\n            // Pack bytes to heads and tails\n            if (before % 8 !== 0) {\n              throw new Error('expected before index should have number of bool mod 8 equal 0');\n            }\n            after = Math.min(7, after);\n            var compressedInt = compressMultipleBool(values.slice(i, i + after + 1));\n            heads.push(bigIntToBytes(compressedInt, 1));\n            i += after;\n          } else {\n            var encodedTupleValue = tupleType.encode(values[i]);\n            heads.push(encodedTupleValue);\n          }\n          isDynamicIndex.set(i, false);\n          tails.push(new Uint8Array());\n        }\n        i += 1;\n      }\n      // Adjust head lengths for dynamic types\n      var headLength = 0;\n      for (var _i = 0, _heads = heads; _i < _heads.length; _i++) {\n        var headElement = _heads[_i];\n        headLength += headElement.length;\n      }\n      // encode any placeholders for dynamic types\n      var tailLength = 0;\n      for (var j = 0; j < heads.length; j++) {\n        if (isDynamicIndex.get(j)) {\n          var headValue = headLength + tailLength;\n          if (headValue > MAX_LEN) {\n            throw new Error(\"byte length of \".concat(headValue, \" should not exceed a uint16\"));\n          }\n          heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n        }\n        tailLength += tails[j].length;\n      }\n      return concatArrays.apply(void 0, heads.concat(tails));\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(byteString) {\n      var tupleTypes = this.childTypes;\n      var dynamicSegments = [];\n      var valuePartition = [];\n      var i = 0;\n      var iterIndex = 0;\n      var buf = Buffer.from(byteString);\n      while (i < tupleTypes.length) {\n        var tupleType = tupleTypes[i];\n        if (tupleType.isDynamic()) {\n          if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {\n            throw new Error('dynamic type in tuple is too short to be decoded');\n          }\n          var dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);\n          if (dynamicSegments.length > 0) {\n            dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n            // Check that right side of segment is greater than the left side\n            if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n              throw new Error('dynamic index segment miscalculation: left is greater than right index');\n            }\n          }\n          // Since we do not know where the current dynamic element ends, put a placeholder and update later\n          var seg = {\n            left: dynamicIndex,\n            right: -1\n          };\n          dynamicSegments.push(seg);\n          valuePartition.push(null);\n          iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (tupleType.constructor === ABIBoolType) {\n            var before = findBoolLR(this.childTypes, i, -1);\n            var after = findBoolLR(this.childTypes, i, 1);\n            if (before % 8 !== 0) {\n              throw new Error('expected before bool number mod 8 === 0');\n            }\n            after = Math.min(7, after);\n            // Parse bool in a byte to multiple byte strings\n            for (var boolIndex = 0; boolIndex <= after; boolIndex++) {\n              var boolMask = 0x80 >> boolIndex;\n              if ((byteString[iterIndex] & boolMask) > 0) {\n                valuePartition.push(new Uint8Array([128]));\n              } else {\n                valuePartition.push(new Uint8Array([0]));\n              }\n            }\n            i += after;\n            iterIndex += 1;\n          } else {\n            var currLen = tupleType.byteLen();\n            valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n            iterIndex += currLen;\n          }\n        }\n        if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n          throw new Error('input byte not enough to decode');\n        }\n        i += 1;\n      }\n      if (dynamicSegments.length > 0) {\n        dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n        iterIndex = byteString.length;\n      }\n      if (iterIndex < byteString.length) {\n        throw new Error('input byte not fully consumed');\n      }\n      // Check segment indices are valid\n      // If the dynamic segment are not consecutive and well-ordered, we return error\n      for (var j = 0; j < dynamicSegments.length; j++) {\n        var _seg = dynamicSegments[j];\n        if (_seg.left > _seg.right) {\n          throw new Error('dynamic segment should display a [l, r] space with l <= r');\n        }\n        if (j !== dynamicSegments.length - 1 && _seg.right !== dynamicSegments[j + 1].left) {\n          throw new Error('dynamic segment should be consecutive');\n        }\n      }\n      // Check dynamic element partitions\n      var segIndex = 0;\n      for (var _j = 0; _j < tupleTypes.length; _j++) {\n        if (tupleTypes[_j].isDynamic()) {\n          valuePartition[_j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);\n          segIndex += 1;\n        }\n      }\n      // Decode each tuple element\n      var returnValues = [];\n      for (var _j2 = 0; _j2 < tupleTypes.length; _j2++) {\n        var valueTi = tupleTypes[_j2].decode(valuePartition[_j2]);\n        returnValues.push(valueTi);\n      }\n      return returnValues;\n    }\n  }], [{\n    key: \"parseTupleContent\",\n    value: function parseTupleContent(str) {\n      if (str.length === 0) {\n        return [];\n      }\n      if (str.endsWith(',') || str.startsWith(',')) {\n        throw new Error('tuple string should not start with comma');\n      }\n      if (str.includes(',,')) {\n        throw new Error('tuple string should not have consecutive commas');\n      }\n      var tupleStrings = [];\n      var depth = 0;\n      var word = '';\n      var _iterator = _createForOfIteratorHelper(str),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var char = _step.value;\n          word += char;\n          if (char === '(') {\n            depth += 1;\n          } else if (char === ')') {\n            depth -= 1;\n          } else if (char === ',') {\n            // If the comma is at depth 0, then append the word as token.\n            if (depth === 0) {\n              tupleStrings.push(word.slice(0, word.length - 1));\n              word = '';\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (word.length !== 0) {\n        tupleStrings.push(word);\n      }\n      if (depth !== 0) {\n        throw new Error('tuple string has mismatched parentheses');\n      }\n      return tupleStrings;\n    }\n  }]);\n  return ABITupleType;\n}(ABIType);\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList) {\n  var res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (var i = 0; i < valueList.length; i++) {\n    var boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << 7 - i;\n    }\n  }\n  return res;\n}\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList, index, delta) {\n  var until = 0;\n  while (true) {\n    var curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}","map":{"version":3,"names":["Buffer","encodeAddress","decodeAddress","bigIntToBytes","bytesToBigInt","concatArrays","MAX_LEN","Math","pow","ADDR_BYTE_SIZE","SINGLE_BYTE_SIZE","SINGLE_BOOL_SIZE","LENGTH_ENCODE_BYTE_SIZE","staticArrayRegexp","ufixedRegexp","ABIType","_classCallCheck","_createClass","key","value","from","str","endsWith","arrayArgType","slice","length","ABIArrayDynamicType","stringMatches","match","Error","concat","arrayLengthStr","arrayLength","parseInt","arrayType","ABIArrayStaticType","startsWith","digitsOnly","string","_toConsumableArray","every","c","includes","typeSizeStr","typeSize","ABIUintType","ABIByteType","ufixedSize","ufixedPrecision","ABIUfixedType","ABIBoolType","ABIAddressType","ABIStringType","tupleContent","ABITupleType","parseTupleContent","tupleTypes","i","ti","push","_ABIType","_inherits","_super","_createSuper","size","_this","call","bitSize","toString","equals","other","isDynamic","byteLen","encode","BigInt","Number","isSafeInteger","decode","byteString","_ABIType2","_super2","denominator","_this2","precision","_ABIType3","_super3","apply","arguments","Uint8Array","decodedAddress","publicKey","byteLength","_ABIType4","_super4","_ABIType5","_super5","_ABIType6","_super6","encodedBytes","encodedLength","mergedBytes","set","buf","readUIntBE","byteValue","_ABIType7","_super7","argType","_this3","childType","staticLength","constructor","ceil","Array","isArray","convertedTuple","toABITupleType","fill","_ABIType8","_super8","_this4","encodedTuple","childTypes","_ABIType9","_super9","argTypes","_this5","typeStrings","join","child","index","some","after","findBoolLR","boolNum","trunc","childByteSize","values","heads","tails","isDynamicIndex","Map","tupleType","before","min","compressedInt","compressMultipleBool","encodedTupleValue","headLength","_i","_heads","headElement","tailLength","j","get","headValue","dynamicSegments","valuePartition","iterIndex","dynamicIndex","right","left","seg","boolIndex","boolMask","currLen","segIndex","returnValues","valueTi","tupleStrings","depth","word","_iterator","_createForOfIteratorHelper","_step","s","n","done","char","err","e","f","valueList","res","boolVal","typeList","delta","until","curr"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/abi/abi_type.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { Buffer } from 'buffer';\nimport { encodeAddress, decodeAddress } from '../encoding/address';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint';\nimport { concatArrays } from '../utils/utils';\n\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\n\ninterface Segment {\n  left: number;\n  right: number;\n}\n\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\n\nexport type ABIValue =\n  | boolean\n  | number\n  | bigint\n  | string\n  | Uint8Array\n  | ABIValue[];\n\nexport abstract class ABIType {\n  // Converts a ABIType object to a string\n  abstract toString(): string;\n  // Checks if two ABIType objects are equal in value\n  abstract equals(other: ABIType): boolean;\n  // Checks if the ABIType object (or any of its child types) have dynamic length\n  abstract isDynamic(): boolean;\n  // Returns the size of the ABIType object in bytes\n  abstract byteLen(): number;\n  // Encodes a value for the ABIType object using the ABI specs\n  abstract encode(value: ABIValue): Uint8Array;\n  // Decodes a value for the ABIType object using the ABI specs\n  abstract decode(byteString: Uint8Array): ABIValue;\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str: string): ABIType {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = (string) =>\n        [...string].every((c) => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(\n        str.slice(1, str.length - 1)\n      );\n      const tupleTypes: ABIType[] = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\n\nexport class ABIUintType extends ABIType {\n  bitSize: number;\n\n  constructor(size: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIUfixedType extends ABIType {\n  bitSize: number;\n  precision: number;\n\n  constructor(size: number, denominator: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIUfixedType &&\n      this.bitSize === other.bitSize &&\n      this.precision === other.precision\n    );\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size ${this.toString()}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIAddressType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n    // Return the address if it is already in bytes\n    if (value.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return value;\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\n\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIBoolType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n\n  decode(byteString: Uint8Array): boolean {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\n\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIByteType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n\n  decode(byteString: Uint8Array): number {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\n\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIStringType;\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    const encodedBytes = Buffer.from(value);\n    const encodedLength = bigIntToBytes(\n      encodedBytes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = new Uint8Array(\n      encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE\n    );\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(\n        `byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`\n      );\n    }\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteValue = byteString.slice(\n      LENGTH_ENCODE_BYTE_SIZE,\n      byteString.length\n    );\n    if (byteLength !== byteValue.length) {\n      throw new Error(\n        `string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`\n      );\n    }\n    return Buffer.from(byteValue).toString('utf-8');\n  }\n}\n\nexport class ABIArrayStaticType extends ABIType {\n  childType: ABIType;\n  staticLength: number;\n\n  constructor(argType: ABIType, arrayLength: number) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(\n        `static array must have a non negative length: ${arrayLength}`\n      );\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayStaticType &&\n      this.staticLength === other.staticLength &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(\n        `Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`\n      );\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\n\nexport class ABIArrayDynamicType extends ABIType {\n  childType: ABIType;\n\n  constructor(argType: ABIType) {\n    super();\n    this.childType = argType;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayDynamicType &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(\n      convertedTuple.childTypes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(\n      byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length)\n    );\n  }\n\n  toABITupleType(length: number) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\n\nexport class ABITupleType extends ABIType {\n  childTypes: ABIType[];\n\n  constructor(argTypes: ABIType[]) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error(\n        'tuple type child type number larger than maximum uint16 error'\n      );\n    }\n    this.childTypes = argTypes;\n  }\n\n  toString() {\n    const typeStrings: string[] = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABITupleType &&\n      this.childTypes.length === other.childTypes.length &&\n      this.childTypes.every((child, index) =>\n        child.equals(other.childTypes[index])\n      )\n    );\n  }\n\n  isDynamic() {\n    const isDynamic = (child: ABIType) => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads: Uint8Array[] = [];\n    const tails: Uint8Array[] = [];\n    const isDynamicIndex = new Map<number, boolean>();\n    let i = 0;\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error(\n              'expected before index should have number of bool mod 8 equal 0'\n            );\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(\n            values.slice(i, i + after + 1)\n          );\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(\n            `byte length of ${headValue} should not exceed a uint16`\n          );\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n\n    return concatArrays(...heads, ...tails);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments: Segment[] = [];\n    const valuePartition: Uint8Array[] = [];\n    let i = 0;\n    let iterIndex = 0;\n    const buf = Buffer.from(byteString);\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (\n          byteString.slice(iterIndex, byteString.length).length <\n          LENGTH_ENCODE_BYTE_SIZE\n        ) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error(\n              'dynamic index segment miscalculation: left is greater than right index'\n            );\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg: Segment = {\n          left: dynamicIndex,\n          right: -1,\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error(\n          'dynamic segment should display a [l, r] space with l <= r'\n        );\n      }\n      if (\n        j !== dynamicSegments.length - 1 &&\n        seg.right !== dynamicSegments[j + 1].left\n      ) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(\n          dynamicSegments[segIndex].left,\n          dynamicSegments[segIndex].right\n        );\n        segIndex += 1;\n      }\n    }\n\n    // Decode each tuple element\n    const returnValues: ABIValue[] = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n\n  static parseTupleContent(str: string): string[] {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n\n    const tupleStrings: string[] = [];\n    let depth = 0;\n    let word = '';\n\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList: ABIValue[]): number {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << (7 - i);\n    }\n  }\n  return res;\n}\n\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList: ABIType[], index: number, delta: -1 | 1): number {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}