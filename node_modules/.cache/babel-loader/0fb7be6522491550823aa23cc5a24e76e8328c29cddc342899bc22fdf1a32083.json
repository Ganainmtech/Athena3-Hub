{"ast":null,"code":"import { Buffer } from 'buffer';\n/**\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\n * @param bi - The bigint to convert.\n * @param size - The size of the resulting byte array.\n * @returns A byte array containing the big-endian encoding of the input bigint\n */\nexport function bigIntToBytes(bi, size) {\n  var hex = bi.toString(16);\n  // Pad the hex with zeros so it matches the size in bytes\n  if (hex.length !== size * 2) {\n    hex = hex.padStart(size * 2, '0');\n  }\n  var byteArray = new Uint8Array(hex.length / 2);\n  for (var i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return byteArray;\n}\n/**\n * bytesToBigInt produces a bigint from a binary representation.\n *\n * @param bytes - The Uint8Array to convert.\n * @returns The bigint that was encoded in the input data.\n */\nexport function bytesToBigInt(bytes) {\n  var res = BigInt(0);\n  var buf = Buffer.from(bytes);\n  for (var i = 0; i < bytes.length; i++) {\n    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);\n  }\n  return res;\n}","map":{"version":3,"names":["Buffer","bigIntToBytes","bi","size","hex","toString","length","padStart","byteArray","Uint8Array","i","j","parseInt","slice","bytesToBigInt","bytes","res","BigInt","buf","from","Number","readUIntBE"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/encoding/bigint.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\n/**\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\n * @param bi - The bigint to convert.\n * @param size - The size of the resulting byte array.\n * @returns A byte array containing the big-endian encoding of the input bigint\n */\nexport function bigIntToBytes(bi: bigint | number, size: number) {\n  let hex = bi.toString(16);\n  // Pad the hex with zeros so it matches the size in bytes\n  if (hex.length !== size * 2) {\n    hex = hex.padStart(size * 2, '0');\n  }\n  const byteArray = new Uint8Array(hex.length / 2);\n  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return byteArray;\n}\n\n/**\n * bytesToBigInt produces a bigint from a binary representation.\n *\n * @param bytes - The Uint8Array to convert.\n * @returns The bigint that was encoded in the input data.\n */\nexport function bytesToBigInt(bytes: Uint8Array) {\n  let res = BigInt(0);\n  const buf = Buffer.from(bytes);\n  for (let i = 0; i < bytes.length; i++) {\n    res = BigInt(Number(buf.readUIntBE(i, 1))) + res * BigInt(256);\n  }\n  return res;\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAE/B;;;;;;AAMA,OAAM,SAAUC,aAAaA,CAACC,EAAmB,EAAEC,IAAY;EAC7D,IAAIC,GAAG,GAAGF,EAAE,CAACG,QAAQ,CAAC,EAAE,CAAC;EACzB;EACA,IAAID,GAAG,CAACE,MAAM,KAAKH,IAAI,GAAG,CAAC,EAAE;IAC3BC,GAAG,GAAGA,GAAG,CAACG,QAAQ,CAACJ,IAAI,GAAG,CAAC,EAAE,GAAG,CAAC;;EAEnC,IAAMK,SAAS,GAAG,IAAIC,UAAU,CAACL,GAAG,CAACE,MAAM,GAAG,CAAC,CAAC;EAChD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGN,GAAG,CAACE,MAAM,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAEC,CAAC,IAAI,CAAC,EAAE;IACtDH,SAAS,CAACE,CAAC,CAAC,GAAGE,QAAQ,CAACR,GAAG,CAACS,KAAK,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;;EAElD,OAAOH,SAAS;AAClB;AAEA;;;;;;AAMA,OAAM,SAAUM,aAAaA,CAACC,KAAiB;EAC7C,IAAIC,GAAG,GAAGC,MAAM,CAAC,CAAC,CAAC;EACnB,IAAMC,GAAG,GAAGlB,MAAM,CAACmB,IAAI,CAACJ,KAAK,CAAC;EAC9B,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,KAAK,CAACT,MAAM,EAAEI,CAAC,EAAE,EAAE;IACrCM,GAAG,GAAGC,MAAM,CAACG,MAAM,CAACF,GAAG,CAACG,UAAU,CAACX,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAGM,GAAG,GAAGC,MAAM,CAAC,GAAG,CAAC;;EAEhE,OAAOD,GAAG;AACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}