{"ast":null,"code":"import _slicedToArray from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nexport var FontGap = 3;\nfunction prepareCanvas(width, height) {\n  var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n  var realWidth = width * ratio;\n  var realHeight = height * ratio;\n  canvas.setAttribute('width', \"\".concat(realWidth, \"px\"));\n  canvas.setAttribute('height', \"\".concat(realHeight, \"px\"));\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    var _prepareCanvas = prepareCanvas(width, height, ratio),\n      _prepareCanvas2 = _slicedToArray(_prepareCanvas, 4),\n      ctx = _prepareCanvas2[0],\n      canvas = _prepareCanvas2[1],\n      contentWidth = _prepareCanvas2[2],\n      contentHeight = _prepareCanvas2[3];\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      var color = font.color,\n        fontSize = font.fontSize,\n        fontStyle = font.fontStyle,\n        fontWeight = font.fontWeight,\n        fontFamily = font.fontFamily,\n        textAlign = font.textAlign;\n      var mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = \"\".concat(fontStyle, \" normal \").concat(fontWeight, \" \").concat(mergedFontSize, \"px/\").concat(height, \"px \").concat(fontFamily);\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      var contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach(function (item, index) {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    }\n    // ==================== Rotate ====================\n    var angle = Math.PI / 180 * Number(rotate);\n    var maxSize = Math.max(width, height);\n    var _prepareCanvas3 = prepareCanvas(maxSize, maxSize, ratio),\n      _prepareCanvas4 = _slicedToArray(_prepareCanvas3, 3),\n      rCtx = _prepareCanvas4[0],\n      rCanvas = _prepareCanvas4[1],\n      realMaxSize = _prepareCanvas4[2];\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    // Get boundary of rotated text\n    function getRotatePos(x, y) {\n      var targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      var targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    var left = 0;\n    var right = 0;\n    var top = 0;\n    var bottom = 0;\n    var halfWidth = contentWidth / 2;\n    var halfHeight = contentHeight / 2;\n    var points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n      var _getRotatePos = getRotatePos(x, y),\n        _getRotatePos2 = _slicedToArray(_getRotatePos, 2),\n        targetX = _getRotatePos2[0],\n        targetY = _getRotatePos2[1];\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    var cutLeft = left + realMaxSize / 2;\n    var cutTop = top + realMaxSize / 2;\n    var cutWidth = right - left;\n    var cutHeight = bottom - top;\n    // ================ Fill Alternate ================\n    var realGapX = gapX * ratio;\n    var realGapY = gapY * ratio;\n    var filledWidth = (cutWidth + realGapX) * 2;\n    var filledHeight = cutHeight + realGapY;\n    var _prepareCanvas5 = prepareCanvas(filledWidth, filledHeight),\n      _prepareCanvas6 = _slicedToArray(_prepareCanvas5, 2),\n      fCtx = _prepareCanvas6[0],\n      fCanvas = _prepareCanvas6[1];\n    function drawImg() {\n      var targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}","map":{"version":3,"names":["FontGap","prepareCanvas","width","height","ratio","arguments","length","undefined","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","concat","save","useClips","getClips","content","rotate","font","gapX","gapY","_prepareCanvas","_prepareCanvas2","_slicedToArray","contentWidth","contentHeight","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","mergedFontSize","Number","fillStyle","textBaseline","contents","Array","isArray","forEach","item","index","fillText","angle","Math","PI","maxSize","max","_prepareCanvas3","_prepareCanvas4","rCtx","rCanvas","realMaxSize","translate","getRotatePos","x","y","targetX","cos","sin","targetY","left","right","top","bottom","halfWidth","halfHeight","points","_ref","_ref2","_getRotatePos","_getRotatePos2","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","_prepareCanvas5","_prepareCanvas6","fCtx","fCanvas","drawImg","toDataURL"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/antd/es/watermark/useClips.js"],"sourcesContent":["export const FontGap = 3;\nfunction prepareCanvas(width, height) {\n  let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute('width', `${realWidth}px`);\n  canvas.setAttribute('height', `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    }\n    // ==================== Rotate ====================\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    // Get boundary of rotated text\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(_ref => {\n      let [x, y] = _ref;\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    function drawImg() {\n      let targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}