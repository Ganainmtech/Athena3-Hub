{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\n/**\n Utilities for manipulating multisig transaction blobs.\n */\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}) {\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map(pk => ({\n    pk: Buffer.from(pk)\n  }));\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn = {\n    msig,\n    txn: txnForEncoding\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(txn, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map(pk => address.encodeAddress(pk))\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig);\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  signTxn(sk) {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk) {\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(metadata, signerAddr, signature) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: signature,\n      myPk: address.decodeAddress(signerAddr).publicKey\n    }, metadata);\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(txnForEnc) {\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();\n  const refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(subsig => subsig.pk)\n  };\n  const refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));\n  const newSubsigs = refSigTx.msig.subsig.map(sig => ({\n    ...sig\n  }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    const authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const signedTxn = {\n    msig,\n    txn: refSigTx.txn\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  let pk;\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, signerAddr, signature) {\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({\n    version,\n    threshold,\n    pks\n  }, signerAddr, signature);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs\n}) {\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","createMultisigTransaction","txn","version","threshold","addrs","pks","map","addr","decodeAddress","publicKey","subsigs","pk","from","msig","v","thr","subsig","txnForEncoding","get_obj_for_encoding","signedTxn","msigAddr","fromMultisigPreImg","encodeAddress","snd","sgnr","Uint8Array","encode","createMultisigTransactionWithSignature","rawSig","myPk","encodedMsig","decode","keyExist","forEach","i","bytesEqual","s","Error","MultisigTransaction","Transaction","addLease","addRekey","signTxn","sk","partialSignTxn","keyPairFromSecretKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","from_obj_for_encoding","txnForEnc","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","undefined","refPreImage","refMsigAddr","newSubsigs","sig","unisig","unisigAlgoTxn","authAddr","preimg","msgigAddr","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","verifiedCounter","verify","signMultisigTransaction","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","call","txnAlreadyBuilt","algoTxn","blob","toString","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","msigTxn","partialSignedBlob","appendSignRawMultisigSignature","multisigAddress"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/node_modules/algosdk/src/multisig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\nimport AnyTransaction, { EncodedTransaction } from './types/transactions';\nimport { MultisigMetadata } from './types/multisig';\nimport {\n  EncodedMultisig,\n  EncodedSignedTransaction,\n} from './types/transactions/encoded';\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\n  'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG =\n  'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\n  'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG =\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG =\n  'Cannot add multisig signature. Signature is not of the correct length.';\n\ninterface MultisigOptions {\n  rawSig: Uint8Array;\n  myPk: Uint8Array;\n}\n\ninterface MultisigMetadataWithPks extends Omit<MultisigMetadata, 'addrs'> {\n  pks: Uint8Array[];\n}\n\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(\n  txn: txnBuilder.Transaction,\n  { version, threshold, addrs }: MultisigMetadata\n) {\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));\n\n  const msig: EncodedMultisig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs,\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: txnForEncoding,\n  };\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(txnForEncoding.snd) !==\n    address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(\n  txn: txnBuilder.Transaction,\n  { rawSig, myPk }: MultisigOptions,\n  { version, threshold, pks }: MultisigMetadataWithPks\n) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map((pk) => address.encodeAddress(pk)),\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig) as EncodedSignedTransaction;\n\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as traditional signing is not allowed\n   */\n  signTxn(sk: Uint8Array): Uint8Array; // This overload ensures that the override has a compatible type definition with the parent method\n  signTxn(sk: any): any {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn(\n    { version, threshold, pks }: MultisigMetadataWithPks,\n    sk: Uint8Array\n  ) {\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(\n      this,\n      { rawSig: this.rawSignTxn(sk), myPk },\n      { version, threshold, pks }\n    );\n  }\n\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(\n    metadata: MultisigMetadataWithPks,\n    signerAddr: string,\n    signature: Uint8Array\n  ) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(\n      this,\n      {\n        rawSig: signature,\n        myPk: address.decodeAddress(signerAddr).publicKey,\n      },\n      metadata\n    );\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(\n    txnForEnc: EncodedTransaction\n  ): MultisigTransaction {\n    return super.from_obj_for_encoding(txnForEnc) as MultisigTransaction;\n  }\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(\n    multisigTxnBlobs[0]\n  ) as EncodedSignedTransaction;\n  const refTxID = MultisigTransaction.from_obj_for_encoding(\n    refSigTx.txn\n  ).txID();\n  const refAuthAddr = refSigTx.sgnr\n    ? address.encodeAddress(refSigTx.sgnr)\n    : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),\n  };\n  const refMsigAddr = address.encodeAddress(\n    address.fromMultisigPreImg(refPreImage)\n  );\n\n  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(\n      multisigTxnBlobs[i]\n    ) as EncodedSignedTransaction;\n\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n\n    const authAddr = unisig.sgnr\n      ? address.encodeAddress(unisig.sgnr)\n      : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg: MultisigMetadataWithPks = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (\n        current.s &&\n        Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0\n      ) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig: EncodedMultisig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs,\n  };\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: refSigTx.txn,\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\nexport function verifyMultisig(\n  toBeVerified: Uint8Array,\n  msig: EncodedMultisig,\n  publicKey: Uint8Array\n) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n\n  const pks = subsigs.map((subsig) => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk: Uint8Array;\n  try {\n    pk = address.fromMultisigPreImg({ version, threshold, pks });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(\n  txn: txnBuilder.TransactionLike,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs,\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn: MultisigTransaction;\n  let blob: Uint8Array;\n  if (txnAlreadyBuilt) {\n    algoTxn = (txn as unknown) as MultisigTransaction;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(\n      algoTxn,\n      { version, threshold, pks },\n      sk\n    );\n  } else {\n    algoTxn = new MultisigTransaction(txn as AnyTransaction);\n    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob,\n  };\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn(\n    { version, threshold, pks },\n    sk\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  signerAddr: string,\n  signature: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature(\n    { version, threshold, pks },\n    signerAddr,\n    signature\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs,\n}: MultisigMetadata) {\n  return address.fromMultisigPreImgAddrs({ version, threshold, addrs });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}