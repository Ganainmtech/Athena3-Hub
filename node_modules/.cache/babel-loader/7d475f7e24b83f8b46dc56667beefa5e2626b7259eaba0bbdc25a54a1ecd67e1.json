{"ast":null,"code":"import _slicedToArray from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as _address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport { verifyMultisig } from './multisig';\nimport * as utils from './utils/utils';\nimport * as txnBuilder from './transaction';\nimport { isValidAddress } from './encoding/address';\n/** sanityCheckProgram performs heuristic program validation:\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\n *\n * @param program - Program bytes to check\n */\nexport function sanityCheckProgram(program) {\n  if (!program || program.length === 0) throw new Error('empty program');\n  var lineBreakOrd = '\\n'.charCodeAt(0);\n  var blankSpaceOrd = ' '.charCodeAt(0);\n  var tildeOrd = '~'.charCodeAt(0);\n  var isPrintable = function isPrintable(x) {\n    return blankSpaceOrd <= x && x <= tildeOrd;\n  };\n  var isAsciiPrintable = program.every(function (x) {\n    return x === lineBreakOrd || isPrintable(x);\n  });\n  if (isAsciiPrintable) {\n    var programStr = Buffer.from(program).toString();\n    if (isValidAddress(programStr)) throw new Error('requesting program bytes, get Algorand address');\n    if (Buffer.from(programStr, 'base64').toString('base64') === programStr) throw new Error('program should not be b64 encoded');\n    throw new Error('program bytes are all ASCII printable characters, not looking like Teal byte code');\n  }\n}\n/**\n LogicSig implementation\n\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\n */\nexport var LogicSig = /*#__PURE__*/function () {\n  function LogicSig(program, programArgs) {\n    _classCallCheck(this, LogicSig);\n    this.tag = Buffer.from('Program');\n    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every(function (arg) {\n      return arg.constructor === Uint8Array || Buffer.isBuffer(arg);\n    }))) {\n      throw new TypeError('Invalid arguments');\n    }\n    var args;\n    if (programArgs != null) args = programArgs.map(function (arg) {\n      return new Uint8Array(arg);\n    });\n    sanityCheckProgram(program);\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  _createClass(LogicSig, [{\n    key: \"get_obj_for_encoding\",\n    value: function get_obj_for_encoding() {\n      var obj = {\n        l: this.logic\n      };\n      if (this.args) {\n        obj.arg = this.args;\n      }\n      if (this.sig) {\n        obj.sig = this.sig;\n      } else if (this.msig) {\n        obj.msig = this.msig;\n      }\n      return obj;\n    }\n    // eslint-disable-next-line camelcase\n  }, {\n    key: \"verify\",\n    value:\n    /**\n     * Performs signature verification\n     * @param publicKey - Verification key (derived from sender address or escrow address)\n     */\n    function verify(publicKey) {\n      if (this.sig && this.msig) {\n        return false;\n      }\n      try {\n        sanityCheckProgram(this.logic);\n      } catch (e) {\n        return false;\n      }\n      var toBeSigned = utils.concatArrays(this.tag, this.logic);\n      if (!this.sig && !this.msig) {\n        var hash = nacl.genericHash(toBeSigned);\n        return utils.arrayEqual(hash, publicKey);\n      }\n      if (this.sig) {\n        return nacl.verify(toBeSigned, this.sig, publicKey);\n      }\n      return verifyMultisig(toBeSigned, this.msig, publicKey);\n    }\n    /**\n     * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n     * @returns String representation of the address\n     */\n  }, {\n    key: \"address\",\n    value: function address() {\n      var toBeSigned = utils.concatArrays(this.tag, this.logic);\n      var hash = nacl.genericHash(toBeSigned);\n      return _address.encodeAddress(new Uint8Array(hash));\n    }\n    /**\n     * Creates signature (if no msig provided) or multi signature otherwise\n     * @param secretKey - Secret key to sign with\n     * @param msig - Multisig account as \\{version, threshold, addrs\\}\n     */\n  }, {\n    key: \"sign\",\n    value: function sign(secretKey, msig) {\n      if (msig == null) {\n        this.sig = this.signProgram(secretKey);\n      } else {\n        var subsigs = msig.addrs.map(function (addr) {\n          return {\n            pk: _address.decodeAddress(addr).publicKey\n          };\n        });\n        this.msig = {\n          v: msig.version,\n          thr: msig.threshold,\n          subsig: subsigs\n        };\n        var _this$singleSignMulti = this.singleSignMultisig(secretKey, this.msig),\n          _this$singleSignMulti2 = _slicedToArray(_this$singleSignMulti, 2),\n          sig = _this$singleSignMulti2[0],\n          index = _this$singleSignMulti2[1];\n        this.msig.subsig[index].s = sig;\n      }\n    }\n    /**\n     * Appends a signature to multi signature\n     * @param secretKey - Secret key to sign with\n     */\n  }, {\n    key: \"appendToMultisig\",\n    value: function appendToMultisig(secretKey) {\n      if (this.msig === undefined) {\n        throw new Error('no multisig present');\n      }\n      var _this$singleSignMulti3 = this.singleSignMultisig(secretKey, this.msig),\n        _this$singleSignMulti4 = _slicedToArray(_this$singleSignMulti3, 2),\n        sig = _this$singleSignMulti4[0],\n        index = _this$singleSignMulti4[1];\n      this.msig.subsig[index].s = sig;\n    }\n  }, {\n    key: \"signProgram\",\n    value: function signProgram(secretKey) {\n      var toBeSigned = utils.concatArrays(this.tag, this.logic);\n      var sig = nacl.sign(toBeSigned, secretKey);\n      return sig;\n    }\n  }, {\n    key: \"singleSignMultisig\",\n    value: function singleSignMultisig(secretKey, msig) {\n      var index = -1;\n      var myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n      for (var i = 0; i < msig.subsig.length; i++) {\n        var pk = msig.subsig[i].pk;\n        if (utils.arrayEqual(pk, myPk)) {\n          index = i;\n          break;\n        }\n      }\n      if (index === -1) {\n        throw new Error('invalid secret key');\n      }\n      var sig = this.signProgram(secretKey);\n      return [sig, index];\n    }\n  }, {\n    key: \"toByte\",\n    value: function toByte() {\n      return encoding.encode(this.get_obj_for_encoding());\n    }\n  }], [{\n    key: \"from_obj_for_encoding\",\n    value: function from_obj_for_encoding(encoded) {\n      var lsig = new LogicSig(encoded.l, encoded.arg);\n      lsig.sig = encoded.sig;\n      lsig.msig = encoded.msig;\n      return lsig;\n    }\n  }, {\n    key: \"fromByte\",\n    value: function fromByte(encoded) {\n      var decodedObj = encoding.decode(encoded);\n      return LogicSig.from_obj_for_encoding(decodedObj);\n    }\n  }]);\n  return LogicSig;\n}();\n/**\n * Represents an account that can sign with a LogicSig program.\n */\nexport var LogicSigAccount = /*#__PURE__*/function () {\n  /**\n   * Create a new LogicSigAccount. By default this will create an escrow\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\n   * LogicSigAccount to make it a delegated account.\n   *\n   * @param program - The compiled TEAL program which contains the logic for\n   *   this LogicSig.\n   * @param args - An optional array of arguments for the program.\n   */\n  function LogicSigAccount(program, args) {\n    _classCallCheck(this, LogicSigAccount);\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  _createClass(LogicSigAccount, [{\n    key: \"get_obj_for_encoding\",\n    value: function get_obj_for_encoding() {\n      var obj = {\n        lsig: this.lsig.get_obj_for_encoding()\n      };\n      if (this.sigkey) {\n        obj.sigkey = this.sigkey;\n      }\n      return obj;\n    }\n    // eslint-disable-next-line camelcase\n  }, {\n    key: \"toByte\",\n    value:\n    /**\n     * Encode this object into msgpack.\n     */\n    function toByte() {\n      return encoding.encode(this.get_obj_for_encoding());\n    }\n    /**\n     * Decode a msgpack object into a LogicSigAccount.\n     * @param encoded - The encoded LogicSigAccount.\n     */\n  }, {\n    key: \"isDelegated\",\n    value:\n    /**\n     * Check if this LogicSigAccount has been delegated to another account with a\n     * signature.\n     *\n     * Note this function only checks for the presence of a delegation signature.\n     * To verify the delegation signature, use `verify`.\n     */\n    function isDelegated() {\n      return !!(this.lsig.sig || this.lsig.msig);\n    }\n    /**\n     * Verifies this LogicSig's program and signatures.\n     * @returns true if and only if the LogicSig program and signatures are valid.\n     */\n  }, {\n    key: \"verify\",\n    value: function verify() {\n      var addr = this.address();\n      return this.lsig.verify(_address.decodeAddress(addr).publicKey);\n    }\n    /**\n     * Get the address of this LogicSigAccount.\n     *\n     * If the LogicSig is delegated to another account, this will return the\n     * address of that account.\n     *\n     * If the LogicSig is not delegated to another account, this will return an\n     *  escrow address that is the hash of the LogicSig's program code.\n     */\n  }, {\n    key: \"address\",\n    value: function address() {\n      if (this.lsig.sig && this.lsig.msig) {\n        throw new Error('LogicSig has too many signatures. At most one of sig or msig may be present');\n      }\n      if (this.lsig.sig) {\n        if (!this.sigkey) {\n          throw new Error('Signing key for delegated account is missing');\n        }\n        return _address.encodeAddress(this.sigkey);\n      }\n      if (this.lsig.msig) {\n        var msigMetadata = {\n          version: this.lsig.msig.v,\n          threshold: this.lsig.msig.thr,\n          pks: this.lsig.msig.subsig.map(function (subsig) {\n            return subsig.pk;\n          })\n        };\n        return _address.encodeAddress(_address.fromMultisigPreImg(msigMetadata));\n      }\n      return this.lsig.address();\n    }\n    /**\n     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n     * has the authority to sign transactions on behalf of another account, called\n     * the delegating account. Use this function if the delegating account is a\n     * multisig account.\n     *\n     * @param msig - The multisig delegating account\n     * @param secretKey - The secret key of one of the members of the delegating\n     *   multisig account. Use `appendToMultisig` to add additional signatures\n     *   from other members.\n     */\n  }, {\n    key: \"signMultisig\",\n    value: function signMultisig(msig, secretKey) {\n      this.lsig.sign(secretKey, msig);\n    }\n    /**\n     * Adds an additional signature from a member of the delegating multisig\n     * account.\n     *\n     * @param secretKey - The secret key of one of the members of the delegating\n     *   multisig account.\n     */\n  }, {\n    key: \"appendToMultisig\",\n    value: function appendToMultisig(secretKey) {\n      this.lsig.appendToMultisig(secretKey);\n    }\n    /**\n     * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n     * has the authority to sign transactions on behalf of another account, called\n     * the delegating account. If the delegating account is a multisig account,\n     * use `signMultisig` instead.\n     *\n     * @param secretKey - The secret key of the delegating account.\n     */\n  }, {\n    key: \"sign\",\n    value: function sign(secretKey) {\n      this.lsig.sign(secretKey);\n      this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    }\n  }], [{\n    key: \"from_obj_for_encoding\",\n    value: function from_obj_for_encoding(encoded) {\n      var lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);\n      lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);\n      lsigAccount.sigkey = encoded.sigkey;\n      return lsigAccount;\n    }\n  }, {\n    key: \"fromByte\",\n    value: function fromByte(encoded) {\n      var decodedObj = encoding.decode(encoded);\n      return LogicSigAccount.from_obj_for_encoding(decodedObj);\n    }\n  }]);\n  return LogicSigAccount;\n}();\nfunction signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {\n  if (!lsig.verify(lsigAddress)) {\n    throw new Error('Logic signature verification failed. Ensure the program and signature are valid.');\n  }\n  var signedTxn = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding()\n  };\n  if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {\n    signedTxn.sgnr = Buffer.from(lsigAddress);\n  }\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(signedTxn)\n  };\n}\n/**\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\n * returns a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n */\nexport function signLogicSigTransactionObject(txn, lsigObject) {\n  var lsig;\n  var lsigAddress;\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = _address.decodeAddress(lsigObject.address()).publicKey;\n  } else {\n    lsig = lsigObject;\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = txn.from.publicKey;\n    } else if (lsig.msig) {\n      var msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map(function (subsig) {\n          return subsig.pk;\n        })\n      };\n      lsigAddress = _address.fromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = _address.decodeAddress(lsig.address()).publicKey;\n    }\n  }\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n/**\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\n * a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nexport function signLogicSigTransaction(txn, lsigObject) {\n  var algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return signLogicSigTransactionObject(algoTxn, lsigObject);\n}\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nexport function logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\nvar SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n */\nexport function tealSign(sk, data, programHash) {\n  var parts = utils.concatArrays(_address.decodeAddress(programHash).publicKey, data);\n  var toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.sign(toBeSigned, sk);\n}\n/**\n * verifyTealSign verifies a signature as would the ed25519verify opcode\n * @param data - buffer with original signed data\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\n * @param pk - uint8array with public key to verify against\n */\nexport function verifyTealSign(data, programHash, sig, pk) {\n  var parts = utils.concatArrays(_address.decodeAddress(programHash).publicKey, data);\n  var toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.verify(toBeSigned, sig, pk);\n}\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\nexport function tealSignFromProgram(sk, data, program) {\n  var lsig = new LogicSig(program);\n  var contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","verifyMultisig","utils","txnBuilder","isValidAddress","sanityCheckProgram","program","length","Error","lineBreakOrd","charCodeAt","blankSpaceOrd","tildeOrd","isPrintable","x","isAsciiPrintable","every","programStr","from","toString","LogicSig","programArgs","_classCallCheck","tag","Array","isArray","arg","constructor","Uint8Array","isBuffer","TypeError","args","map","logic","sig","undefined","msig","_createClass","key","value","get_obj_for_encoding","obj","l","verify","publicKey","e","toBeSigned","concatArrays","hash","genericHash","arrayEqual","encodeAddress","sign","secretKey","signProgram","subsigs","addrs","addr","pk","decodeAddress","v","version","thr","threshold","subsig","_this$singleSignMulti","singleSignMultisig","_this$singleSignMulti2","_slicedToArray","index","s","appendToMultisig","_this$singleSignMulti3","_this$singleSignMulti4","myPk","keyPairFromSecretKey","i","toByte","encode","from_obj_for_encoding","encoded","lsig","fromByte","decodedObj","decode","LogicSigAccount","sigkey","isDelegated","msigMetadata","pks","fromMultisigPreImg","signMultisig","lsigAccount","signLogicSigTransactionWithAddress","txn","lsigAddress","signedTxn","bytesEqual","sgnr","txID","blob","signLogicSigTransactionObject","lsigObject","signLogicSigTransaction","algoTxn","instantiateTxnIfNeeded","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","data","programHash","parts","verifyTealSign","tealSignFromProgram","contractAddress"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/logicsig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport { verifyMultisig } from './multisig';\nimport * as utils from './utils/utils';\nimport * as txnBuilder from './transaction';\nimport { isValidAddress } from './encoding/address';\nimport {\n  EncodedLogicSig,\n  EncodedLogicSigAccount,\n  EncodedMultisig,\n  EncodedSignedTransaction,\n} from './types/transactions/encoded';\nimport { MultisigMetadata } from './types/multisig';\n\ninterface LogicSigStorageStructure {\n  logic: Uint8Array;\n  args: Uint8Array[];\n  sig?: Uint8Array;\n  msig?: EncodedMultisig;\n}\n\n/** sanityCheckProgram performs heuristic program validation:\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\n *\n * @param program - Program bytes to check\n */\nexport function sanityCheckProgram(program: Uint8Array) {\n  if (!program || program.length === 0) throw new Error('empty program');\n\n  const lineBreakOrd = '\\n'.charCodeAt(0);\n  const blankSpaceOrd = ' '.charCodeAt(0);\n  const tildeOrd = '~'.charCodeAt(0);\n\n  const isPrintable = (x: number) => blankSpaceOrd <= x && x <= tildeOrd;\n  const isAsciiPrintable = program.every(\n    (x: number) => x === lineBreakOrd || isPrintable(x)\n  );\n\n  if (isAsciiPrintable) {\n    const programStr = Buffer.from(program).toString();\n\n    if (isValidAddress(programStr))\n      throw new Error('requesting program bytes, get Algorand address');\n\n    if (Buffer.from(programStr, 'base64').toString('base64') === programStr)\n      throw new Error('program should not be b64 encoded');\n\n    throw new Error(\n      'program bytes are all ASCII printable characters, not looking like Teal byte code'\n    );\n  }\n}\n\n/**\n LogicSig implementation\n\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\n */\nexport class LogicSig implements LogicSigStorageStructure {\n  tag = Buffer.from('Program');\n\n  logic: Uint8Array;\n  args: Uint8Array[];\n  sig?: Uint8Array;\n  msig?: EncodedMultisig;\n\n  constructor(\n    program: Uint8Array,\n    programArgs?: Array<Uint8Array | Buffer> | null\n  ) {\n    if (\n      programArgs &&\n      (!Array.isArray(programArgs) ||\n        !programArgs.every(\n          (arg) => arg.constructor === Uint8Array || Buffer.isBuffer(arg)\n        ))\n    ) {\n      throw new TypeError('Invalid arguments');\n    }\n\n    let args: Uint8Array[] | undefined;\n    if (programArgs != null)\n      args = programArgs.map((arg) => new Uint8Array(arg));\n\n    sanityCheckProgram(program);\n\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj: EncodedLogicSig = {\n      l: this.logic,\n    };\n    if (this.args) {\n      obj.arg = this.args;\n    }\n    if (this.sig) {\n      obj.sig = this.sig;\n    } else if (this.msig) {\n      obj.msig = this.msig;\n    }\n    return obj;\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded: EncodedLogicSig) {\n    const lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n\n  /**\n   * Performs signature verification\n   * @param publicKey - Verification key (derived from sender address or escrow address)\n   */\n  verify(publicKey: Uint8Array) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n\n    try {\n      sanityCheckProgram(this.logic);\n    } catch (e) {\n      return false;\n    }\n\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n\n    return verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns String representation of the address\n   */\n  address() {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(new Uint8Array(hash));\n  }\n\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param secretKey - Secret key to sign with\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\n   */\n  sign(secretKey: Uint8Array, msig?: MultisigMetadata) {\n    if (msig == null) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = msig.addrs.map((addr) => ({\n        pk: address.decodeAddress(addr).publicKey,\n      }));\n\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs,\n      };\n\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n\n  /**\n   * Appends a signature to multi signature\n   * @param secretKey - Secret key to sign with\n   */\n  appendToMultisig(secretKey: Uint8Array) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n\n  signProgram(secretKey: Uint8Array) {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n\n  singleSignMultisig(\n    secretKey: Uint8Array,\n    msig: EncodedMultisig\n  ): [sig: Uint8Array, index: number] {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const { pk } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n  static fromByte(encoded: ArrayLike<any>) {\n    const decodedObj = encoding.decode(encoded) as EncodedLogicSig;\n    return LogicSig.from_obj_for_encoding(decodedObj);\n  }\n}\n\n/**\n * Represents an account that can sign with a LogicSig program.\n */\nexport class LogicSigAccount {\n  lsig: LogicSig;\n  sigkey?: Uint8Array;\n\n  /**\n   * Create a new LogicSigAccount. By default this will create an escrow\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\n   * LogicSigAccount to make it a delegated account.\n   *\n   * @param program - The compiled TEAL program which contains the logic for\n   *   this LogicSig.\n   * @param args - An optional array of arguments for the program.\n   */\n  constructor(program: Uint8Array, args?: Array<Uint8Array | Buffer> | null) {\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj: EncodedLogicSigAccount = {\n      lsig: this.lsig.get_obj_for_encoding(),\n    };\n    if (this.sigkey) {\n      obj.sigkey = this.sigkey;\n    }\n    return obj;\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded: EncodedLogicSigAccount) {\n    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);\n    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);\n    lsigAccount.sigkey = encoded.sigkey;\n    return lsigAccount;\n  }\n\n  /**\n   * Encode this object into msgpack.\n   */\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n\n  /**\n   * Decode a msgpack object into a LogicSigAccount.\n   * @param encoded - The encoded LogicSigAccount.\n   */\n  static fromByte(encoded: ArrayLike<any>) {\n    const decodedObj = encoding.decode(encoded) as EncodedLogicSigAccount;\n    return LogicSigAccount.from_obj_for_encoding(decodedObj);\n  }\n\n  /**\n   * Check if this LogicSigAccount has been delegated to another account with a\n   * signature.\n   *\n   * Note this function only checks for the presence of a delegation signature.\n   * To verify the delegation signature, use `verify`.\n   */\n  isDelegated() {\n    return !!(this.lsig.sig || this.lsig.msig);\n  }\n\n  /**\n   * Verifies this LogicSig's program and signatures.\n   * @returns true if and only if the LogicSig program and signatures are valid.\n   */\n  verify() {\n    const addr = this.address();\n    return this.lsig.verify(address.decodeAddress(addr).publicKey);\n  }\n\n  /**\n   * Get the address of this LogicSigAccount.\n   *\n   * If the LogicSig is delegated to another account, this will return the\n   * address of that account.\n   *\n   * If the LogicSig is not delegated to another account, this will return an\n   *  escrow address that is the hash of the LogicSig's program code.\n   */\n  address() {\n    if (this.lsig.sig && this.lsig.msig) {\n      throw new Error(\n        'LogicSig has too many signatures. At most one of sig or msig may be present'\n      );\n    }\n\n    if (this.lsig.sig) {\n      if (!this.sigkey) {\n        throw new Error('Signing key for delegated account is missing');\n      }\n      return address.encodeAddress(this.sigkey);\n    }\n\n    if (this.lsig.msig) {\n      const msigMetadata = {\n        version: this.lsig.msig.v,\n        threshold: this.lsig.msig.thr,\n        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk),\n      };\n      return address.encodeAddress(address.fromMultisigPreImg(msigMetadata));\n    }\n\n    return this.lsig.address();\n  }\n\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. Use this function if the delegating account is a\n   * multisig account.\n   *\n   * @param msig - The multisig delegating account\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account. Use `appendToMultisig` to add additional signatures\n   *   from other members.\n   */\n  signMultisig(msig: MultisigMetadata, secretKey: Uint8Array) {\n    this.lsig.sign(secretKey, msig);\n  }\n\n  /**\n   * Adds an additional signature from a member of the delegating multisig\n   * account.\n   *\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account.\n   */\n  appendToMultisig(secretKey: Uint8Array) {\n    this.lsig.appendToMultisig(secretKey);\n  }\n\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. If the delegating account is a multisig account,\n   * use `signMultisig` instead.\n   *\n   * @param secretKey - The secret key of the delegating account.\n   */\n  sign(secretKey: Uint8Array) {\n    this.lsig.sign(secretKey);\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n  }\n}\n\nfunction signLogicSigTransactionWithAddress(\n  txn: txnBuilder.Transaction,\n  lsig: LogicSig,\n  lsigAddress: Uint8Array\n) {\n  if (!lsig.verify(lsigAddress)) {\n    throw new Error(\n      'Logic signature verification failed. Ensure the program and signature are valid.'\n    );\n  }\n\n  const signedTxn: EncodedSignedTransaction = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding(),\n  };\n\n  if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {\n    signedTxn.sgnr = Buffer.from(lsigAddress);\n  }\n\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(signedTxn),\n  };\n}\n\n/**\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\n * returns a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n */\nexport function signLogicSigTransactionObject(\n  txn: txnBuilder.Transaction,\n  lsigObject: LogicSig | LogicSigAccount\n) {\n  let lsig: LogicSig;\n  let lsigAddress: Uint8Array;\n\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = address.decodeAddress(lsigObject.address()).publicKey;\n  } else {\n    lsig = lsigObject;\n\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = txn.from.publicKey;\n    } else if (lsig.msig) {\n      const msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map((subsig) => subsig.pk),\n      };\n      lsigAddress = address.fromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = address.decodeAddress(lsig.address()).publicKey;\n    }\n  }\n\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n\n/**\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\n * a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nexport function signLogicSigTransaction(\n  txn: txnBuilder.TransactionLike,\n  lsigObject: LogicSig | LogicSigAccount\n) {\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return signLogicSigTransactionObject(algoTxn, lsigObject);\n}\n\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nexport function logicSigFromByte(encoded: Uint8Array) {\n  return LogicSig.fromByte(encoded);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n */\nexport function tealSign(\n  sk: Uint8Array,\n  data: Uint8Array | Buffer,\n  programHash: string\n) {\n  const parts = utils.concatArrays(\n    address.decodeAddress(programHash).publicKey,\n    data\n  );\n  const toBeSigned = Buffer.from(\n    utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts)\n  );\n  return nacl.sign(toBeSigned, sk);\n}\n\n/**\n * verifyTealSign verifies a signature as would the ed25519verify opcode\n * @param data - buffer with original signed data\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\n * @param pk - uint8array with public key to verify against\n */\nexport function verifyTealSign(\n  data: Uint8Array | Buffer,\n  programHash: string,\n  sig: Uint8Array,\n  pk: Uint8Array\n) {\n  const parts = utils.concatArrays(\n    address.decodeAddress(programHash).publicKey,\n    data\n  );\n  const toBeSigned = Buffer.from(\n    utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts)\n  );\n  return nacl.verify(toBeSigned, sig, pk);\n}\n\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\nexport function tealSignFromProgram(\n  sk: Uint8Array,\n  data: Uint8Array | Buffer,\n  program: Uint8Array\n) {\n  const lsig = new LogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}