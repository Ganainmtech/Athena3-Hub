{"ast":null,"code":"import { Buffer } from 'buffer';\nimport base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as utils from '../utils/utils';\nimport { encodeUint64 } from './uint64';\nvar ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nvar ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nvar ALGORAND_ADDRESS_LENGTH = 58;\nexport var ALGORAND_ZERO_ADDRESS_STRING = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n// Convert \"MultisigAddr\" UTF-8 to byte array\nvar MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nvar APP_ID_PREFIX = Buffer.from('appID');\nexport var MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport var CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nexport var INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nexport var INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nexport var INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nexport var UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n */\nexport function decodeAddress(address) {\n  if (typeof address !== 'string' || address.length !== ALGORAND_ADDRESS_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // try to decode\n  var decoded = base32.decode.asBytes(address.toString());\n  // Sanity check\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // Find publickey and checksum\n  var pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  var cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n  // Compute checksum\n  var checksum = nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH);\n  // Check if the checksum and the address are equal\n  if (!utils.arrayEqual(checksum, cs)) throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n  return {\n    publicKey: pk,\n    checksum: cs\n  };\n}\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param address - an Algorand address with checksum.\n * @returns true if valid, false otherwise\n */\nexport function isValidAddress(address) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param address - a raw Algorand address\n * @returns the address and checksum encoded as a string.\n */\nexport function encodeAddress(address) {\n  // compute checksum\n  var checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  var addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - array of typed array public keys\n */\nexport function fromMultisigPreImg(_ref) {\n  var version = _ref.version,\n    threshold = _ref.threshold,\n    pks = _ref.pks;\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  var pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  var merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (var i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Uint8Array(nacl.genericHash(merged));\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - array of encoded addresses\n */\nexport function fromMultisigPreImgAddrs(_ref2) {\n  var version = _ref2.version,\n    threshold = _ref2.threshold,\n    addrs = _ref2.addrs;\n  var pks = addrs.map(function (addr) {\n    return decodeAddress(addr).publicKey;\n  });\n  return encodeAddress(fromMultisigPreImg({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  }));\n}\n/**\n * Get the escrow address of an application.\n * @param appID - The ID of the application.\n * @returns The address corresponding to that application's escrow account.\n */\nexport function getApplicationAddress(appID) {\n  var toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  var hash = nacl.genericHash(toBeSigned);\n  return encodeAddress(new Uint8Array(hash));\n}","map":{"version":3,"names":["Buffer","base32","nacl","utils","encodeUint64","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","APP_ID_PREFIX","from","MALFORMED_ADDRESS_ERROR_MSG","CHECKSUM_ADDRESS_ERROR_MSG","INVALID_MSIG_VERSION_ERROR_MSG","INVALID_MSIG_THRESHOLD_ERROR_MSG","INVALID_MSIG_PK_ERROR_MSG","UNEXPECTED_PK_LEN_ERROR_MSG","decodeAddress","address","length","Error","decoded","decode","asBytes","toString","pk","slice","cs","PUBLIC_KEY_LENGTH","checksum","genericHash","HASH_BYTES_LENGTH","arrayEqual","publicKey","isValidAddress","e","encodeAddress","addr","encode","concatArrays","fromMultisigPreImg","_ref","version","threshold","pks","pkLen","merged","set","i","fromMultisigPreImgAddrs","_ref2","addrs","map","getApplicationAddress","appID","toBeSigned","hash"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/encoding/address.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as utils from '../utils/utils';\nimport { encodeUint64 } from './uint64';\nimport { Address } from '../types/address';\nimport { MultisigMetadata } from '../types/multisig';\n\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nexport const ALGORAND_ZERO_ADDRESS_STRING =\n  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([\n  77,\n  117,\n  108,\n  116,\n  105,\n  115,\n  105,\n  103,\n  65,\n  100,\n  100,\n  114,\n]);\n\nconst APP_ID_PREFIX = Buffer.from('appID');\n\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nexport const INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nexport const INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nexport const INVALID_MSIG_PK_ERROR_MSG =\n  'bad multisig public key - wrong length';\nexport const UNEXPECTED_PK_LEN_ERROR_MSG =\n  'nacl public key length is not 32 bytes';\n\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n */\nexport function decodeAddress(address: string): Address {\n  if (typeof address !== 'string' || address.length !== ALGORAND_ADDRESS_LENGTH)\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n\n  // try to decode\n  const decoded = base32.decode.asBytes(address.toString());\n  // Sanity check\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n\n  // Find publickey and checksum\n  const pk = new Uint8Array(\n    decoded.slice(\n      0,\n      ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\n    )\n  );\n  const cs = new Uint8Array(\n    decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH)\n  );\n\n  // Compute checksum\n  const checksum = nacl\n    .genericHash(pk)\n    .slice(\n      nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      nacl.HASH_BYTES_LENGTH\n    );\n\n  // Check if the checksum and the address are equal\n  if (!utils.arrayEqual(checksum, cs))\n    throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n\n  return { publicKey: pk, checksum: cs };\n}\n\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param address - an Algorand address with checksum.\n * @returns true if valid, false otherwise\n */\nexport function isValidAddress(address: string) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param address - a raw Algorand address\n * @returns the address and checksum encoded as a string.\n */\nexport function encodeAddress(address: Uint8Array) {\n  // compute checksum\n  const checksum = nacl\n    .genericHash(address)\n    .slice(\n      nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      nacl.PUBLIC_KEY_LENGTH\n    );\n  const addr = base32.encode(utils.concatArrays(address, checksum));\n\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - array of typed array public keys\n */\nexport function fromMultisigPreImg({\n  version,\n  threshold,\n  pks,\n}: Omit<MultisigMetadata, 'addrs'> & {\n  pks: Uint8Array[];\n}) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (\n    threshold === 0 ||\n    pks.length === 0 ||\n    threshold > pks.length ||\n    threshold > 255\n  ) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(\n    MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length\n  );\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Uint8Array(nacl.genericHash(merged));\n}\n\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - array of encoded addresses\n */\nexport function fromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs,\n}: {\n  version: number;\n  threshold: number;\n  addrs: string[];\n}) {\n  const pks = addrs.map((addr) => decodeAddress(addr).publicKey);\n  return encodeAddress(fromMultisigPreImg({ version, threshold, pks }));\n}\n\n/**\n * Get the escrow address of an application.\n * @param appID - The ID of the application.\n * @returns The address corresponding to that application's escrow account.\n */\nexport function getApplicationAddress(appID: number | bigint): string {\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  const hash = nacl.genericHash(toBeSigned);\n  return encodeAddress(new Uint8Array(hash));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}