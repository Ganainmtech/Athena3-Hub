{"ast":null,"code":"import { encodeUnsignedSimulateTransaction } from './transaction';\nimport { signLogicSigTransactionObject } from './logicsig';\nimport { signMultisigTransaction, mergeMultisigTransactions } from './multisig';\n/**\n * Create a TransactionSigner that can sign transactions for the provided basic Account.\n */\nexport function makeBasicAccountTransactionSigner(account) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      signed.push(txnGroup[index].signTxn(account.sk));\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\n * Create a TransactionSigner that can sign transactions for the provided LogicSigAccount.\n */\nexport function makeLogicSigAccountTransactionSigner(account) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      const {\n        blob\n      } = signLogicSigTransactionObject(txnGroup[index], account);\n      signed.push(blob);\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\n * Create a TransactionSigner that can sign transactions for the provided Multisig account.\n * @param msig - The Multisig account metadata\n * @param sks - An array of private keys belonging to the msig which should sign the transactions.\n */\nexport function makeMultiSigAccountTransactionSigner(msig, sks) {\n  return (txnGroup, indexesToSign) => {\n    const signed = [];\n    for (const index of indexesToSign) {\n      const txn = txnGroup[index];\n      const partialSigs = [];\n      for (const sk of sks) {\n        const {\n          blob\n        } = signMultisigTransaction(txn, msig, sk);\n        partialSigs.push(blob);\n      }\n      if (partialSigs.length > 1) {\n        signed.push(mergeMultisigTransactions(partialSigs));\n      } else {\n        signed.push(partialSigs[0]);\n      }\n    }\n    return Promise.resolve(signed);\n  };\n}\n/**\n * Create a makeEmptyTransactionSigner that does not specify any signer or\n * signing capabilities. This should only be used to simulate transactions.\n */\nexport function makeEmptyTransactionSigner() {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  return (txnGroup, indexesToSign) => {\n    const unsigned = [];\n    for (const index of indexesToSign) {\n      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));\n    }\n    return Promise.resolve(unsigned);\n  };\n}\n/**\n * Check if a value conforms to the TransactionWithSigner structure.\n * @param value - The value to check.\n * @returns True if an only if the value has the structure of a TransactionWithSigner.\n */\nexport function isTransactionWithSigner(value) {\n  return typeof value === 'object' && Object.keys(value).length === 2 && typeof value.txn === 'object' && typeof value.signer === 'function';\n}","map":{"version":3,"names":["encodeUnsignedSimulateTransaction","signLogicSigTransactionObject","signMultisigTransaction","mergeMultisigTransactions","makeBasicAccountTransactionSigner","account","txnGroup","indexesToSign","signed","index","push","signTxn","sk","Promise","resolve","makeLogicSigAccountTransactionSigner","blob","makeMultiSigAccountTransactionSigner","msig","sks","txn","partialSigs","length","makeEmptyTransactionSigner","unsigned","isTransactionWithSigner","value","Object","keys","signer"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/signer.ts"],"sourcesContent":["import { encodeUnsignedSimulateTransaction, Transaction } from './transaction';\nimport Account from './types/account';\nimport { LogicSigAccount, signLogicSigTransactionObject } from './logicsig';\nimport { MultisigMetadata } from './types/multisig';\nimport { signMultisigTransaction, mergeMultisigTransactions } from './multisig';\n\n/**\n * This type represents a function which can sign transactions from an atomic transaction group.\n * @param txnGroup - The atomic group containing transactions to be signed\n * @param indexesToSign - An array of indexes in the atomic transaction group that should be signed\n * @returns A promise which resolves an array of encoded signed transactions. The length of the\n *   array will be the same as the length of indexesToSign, and each index i in the array\n *   corresponds to the signed transaction from txnGroup[indexesToSign[i]]\n */\nexport type TransactionSigner = (\n  txnGroup: Transaction[],\n  indexesToSign: number[]\n) => Promise<Uint8Array[]>;\n\n/**\n * Create a TransactionSigner that can sign transactions for the provided basic Account.\n */\nexport function makeBasicAccountTransactionSigner(\n  account: Account\n): TransactionSigner {\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\n    const signed: Uint8Array[] = [];\n\n    for (const index of indexesToSign) {\n      signed.push(txnGroup[index].signTxn(account.sk));\n    }\n\n    return Promise.resolve(signed);\n  };\n}\n\n/**\n * Create a TransactionSigner that can sign transactions for the provided LogicSigAccount.\n */\nexport function makeLogicSigAccountTransactionSigner(\n  account: LogicSigAccount\n): TransactionSigner {\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\n    const signed: Uint8Array[] = [];\n\n    for (const index of indexesToSign) {\n      const { blob } = signLogicSigTransactionObject(txnGroup[index], account);\n      signed.push(blob);\n    }\n\n    return Promise.resolve(signed);\n  };\n}\n\n/**\n * Create a TransactionSigner that can sign transactions for the provided Multisig account.\n * @param msig - The Multisig account metadata\n * @param sks - An array of private keys belonging to the msig which should sign the transactions.\n */\nexport function makeMultiSigAccountTransactionSigner(\n  msig: MultisigMetadata,\n  sks: Uint8Array[]\n): TransactionSigner {\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\n    const signed: Uint8Array[] = [];\n\n    for (const index of indexesToSign) {\n      const txn = txnGroup[index];\n      const partialSigs: Uint8Array[] = [];\n\n      for (const sk of sks) {\n        const { blob } = signMultisigTransaction(txn, msig, sk);\n        partialSigs.push(blob);\n      }\n\n      if (partialSigs.length > 1) {\n        signed.push(mergeMultisigTransactions(partialSigs));\n      } else {\n        signed.push(partialSigs[0]);\n      }\n    }\n\n    return Promise.resolve(signed);\n  };\n}\n\n/**\n * Create a makeEmptyTransactionSigner that does not specify any signer or\n * signing capabilities. This should only be used to simulate transactions.\n */\nexport function makeEmptyTransactionSigner(): TransactionSigner {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  return (txnGroup: Transaction[], indexesToSign: number[]) => {\n    const unsigned: Uint8Array[] = [];\n\n    for (const index of indexesToSign) {\n      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));\n    }\n\n    return Promise.resolve(unsigned);\n  };\n}\n\n/** Represents an unsigned transactions and a signer that can authorize that transaction. */\nexport interface TransactionWithSigner {\n  /** An unsigned transaction */\n  txn: Transaction;\n  /** A transaction signer that can authorize txn */\n  signer: TransactionSigner;\n}\n\n/**\n * Check if a value conforms to the TransactionWithSigner structure.\n * @param value - The value to check.\n * @returns True if an only if the value has the structure of a TransactionWithSigner.\n */\nexport function isTransactionWithSigner(\n  value: any\n): value is TransactionWithSigner {\n  return (\n    typeof value === 'object' &&\n    Object.keys(value).length === 2 &&\n    typeof value.txn === 'object' &&\n    typeof value.signer === 'function'\n  );\n}\n"],"mappings":"AAAA,SAASA,iCAAiC,QAAqB,eAAe;AAE9E,SAA0BC,6BAA6B,QAAQ,YAAY;AAE3E,SAASC,uBAAuB,EAAEC,yBAAyB,QAAQ,YAAY;AAe/E;;;AAGA,OAAM,SAAUC,iCAAiCA,CAC/CC,OAAgB;EAEhB,OAAO,CAACC,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjCC,MAAM,CAACE,IAAI,CAACJ,QAAQ,CAACG,KAAK,CAAC,CAACE,OAAO,CAACN,OAAO,CAACO,EAAE,CAAC,CAAC;;IAGlD,OAAOC,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;AAGA,OAAM,SAAUO,oCAAoCA,CAClDV,OAAwB;EAExB,OAAO,CAACC,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjC,MAAM;QAAES;MAAI,CAAE,GAAGf,6BAA6B,CAACK,QAAQ,CAACG,KAAK,CAAC,EAAEJ,OAAO,CAAC;MACxEG,MAAM,CAACE,IAAI,CAACM,IAAI,CAAC;;IAGnB,OAAOH,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;;;AAKA,OAAM,SAAUS,oCAAoCA,CAClDC,IAAsB,EACtBC,GAAiB;EAEjB,OAAO,CAACb,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMC,MAAM,GAAiB,EAAE;IAE/B,KAAK,MAAMC,KAAK,IAAIF,aAAa,EAAE;MACjC,MAAMa,GAAG,GAAGd,QAAQ,CAACG,KAAK,CAAC;MAC3B,MAAMY,WAAW,GAAiB,EAAE;MAEpC,KAAK,MAAMT,EAAE,IAAIO,GAAG,EAAE;QACpB,MAAM;UAAEH;QAAI,CAAE,GAAGd,uBAAuB,CAACkB,GAAG,EAAEF,IAAI,EAAEN,EAAE,CAAC;QACvDS,WAAW,CAACX,IAAI,CAACM,IAAI,CAAC;;MAGxB,IAAIK,WAAW,CAACC,MAAM,GAAG,CAAC,EAAE;QAC1Bd,MAAM,CAACE,IAAI,CAACP,yBAAyB,CAACkB,WAAW,CAAC,CAAC;OACpD,MAAM;QACLb,MAAM,CAACE,IAAI,CAACW,WAAW,CAAC,CAAC,CAAC,CAAC;;;IAI/B,OAAOR,OAAO,CAACC,OAAO,CAACN,MAAM,CAAC;EAChC,CAAC;AACH;AAEA;;;;AAIA,OAAM,SAAUe,0BAA0BA,CAAA;EACxC;EACA,OAAO,CAACjB,QAAuB,EAAEC,aAAuB,KAAI;IAC1D,MAAMiB,QAAQ,GAAiB,EAAE;IAEjC,KAAK,MAAMf,KAAK,IAAIF,aAAa,EAAE;MACjCiB,QAAQ,CAACd,IAAI,CAACV,iCAAiC,CAACM,QAAQ,CAACG,KAAK,CAAC,CAAC,CAAC;;IAGnE,OAAOI,OAAO,CAACC,OAAO,CAACU,QAAQ,CAAC;EAClC,CAAC;AACH;AAUA;;;;;AAKA,OAAM,SAAUC,uBAAuBA,CACrCC,KAAU;EAEV,OACE,OAAOA,KAAK,KAAK,QAAQ,IACzBC,MAAM,CAACC,IAAI,CAACF,KAAK,CAAC,CAACJ,MAAM,KAAK,CAAC,IAC/B,OAAOI,KAAK,CAACN,GAAG,KAAK,QAAQ,IAC7B,OAAOM,KAAK,CAACG,MAAM,KAAK,UAAU;AAEtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}