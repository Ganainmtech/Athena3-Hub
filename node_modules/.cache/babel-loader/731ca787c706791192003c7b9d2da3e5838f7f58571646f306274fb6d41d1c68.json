{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\n/**\n Utilities for manipulating multisig transaction blobs.\n */\nexport var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport var MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport var MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport var MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport var MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nvar MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport var MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport var MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport var MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(txn, _ref) {\n  var version = _ref.version,\n    threshold = _ref.threshold,\n    addrs = _ref.addrs;\n  // construct the appendable multisigned transaction format\n  var pks = addrs.map(function (addr) {\n    return address.decodeAddress(addr).publicKey;\n  });\n  var subsigs = pks.map(function (pk) {\n    return {\n      pk: Buffer.from(pk)\n    };\n  });\n  var msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  var txnForEncoding = txn.get_obj_for_encoding();\n  var signedTxn = {\n    msig: msig,\n    txn: txnForEncoding\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  var msigAddr = address.fromMultisigPreImg({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  });\n  if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(txn, _ref2, _ref3) {\n  var rawSig = _ref2.rawSig,\n    myPk = _ref2.myPk;\n  var version = _ref3.version,\n    threshold = _ref3.threshold,\n    pks = _ref3.pks;\n  // Create an empty encoded multisig transaction\n  var encodedMsig = createMultisigTransaction(txn, {\n    version: version,\n    threshold: threshold,\n    addrs: pks.map(function (pk) {\n      return address.encodeAddress(pk);\n    })\n  });\n  // note: this is not signed yet, but will be shortly\n  var signedTxn = encoding.decode(encodedMsig);\n  var keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach(function (subsig, i) {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  var msigAddr = address.fromMultisigPreImg({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  });\n  if (address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport var MultisigTransaction = /*#__PURE__*/function (_txnBuilder$Transacti) {\n  _inherits(MultisigTransaction, _txnBuilder$Transacti);\n  var _super = _createSuper(MultisigTransaction);\n  function MultisigTransaction() {\n    _classCallCheck(this, MultisigTransaction);\n    return _super.apply(this, arguments);\n  }\n  _createClass(MultisigTransaction, [{\n    key: \"addLease\",\n    value: /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n    /**\n     * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n     */\n    function addLease() {\n      throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n    }\n    /**\n     * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n     */\n  }, {\n    key: \"addRekey\",\n    value: function addRekey() {\n      throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n    }\n  }, {\n    key: \"signTxn\",\n    value: function signTxn(sk) {\n      throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n    }\n    /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n    /**\n     * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n     * encoded with msgpack as a typed array.\n     * @param version - multisig version\n     * @param threshold - multisig threshold\n     * @param pks - multisig public key list, order is important.\n     * @param sk - an Algorand secret key to sign with.\n     * @returns an encoded, partially signed multisig transaction.\n     */\n  }, {\n    key: \"partialSignTxn\",\n    value: function partialSignTxn(_ref4, sk) {\n      var version = _ref4.version,\n        threshold = _ref4.threshold,\n        pks = _ref4.pks;\n      // get signature verifier\n      var myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n      return createMultisigTransactionWithSignature(this, {\n        rawSig: this.rawSignTxn(sk),\n        myPk: myPk\n      }, {\n        version: version,\n        threshold: threshold,\n        pks: pks\n      });\n    }\n    /**\n     * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n     * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n     * @param metadata - multisig metadata\n     * @param signerAddr - address of the signer\n     * @param signature - raw multisig signature\n     * @returns an encoded, partially signed multisig transaction.\n     */\n  }, {\n    key: \"partialSignWithMultisigSignature\",\n    value: function partialSignWithMultisigSignature(metadata, signerAddr, signature) {\n      if (!nacl.isValidSignatureLength(signature.length)) {\n        throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n      }\n      return createMultisigTransactionWithSignature(this, {\n        rawSig: signature,\n        myPk: address.decodeAddress(signerAddr).publicKey\n      }, metadata);\n    }\n    // eslint-disable-next-line camelcase\n  }], [{\n    key: \"from_obj_for_encoding\",\n    value: function from_obj_for_encoding(txnForEnc) {\n      return _get(_getPrototypeOf(MultisigTransaction), \"from_obj_for_encoding\", this).call(this, txnForEnc);\n    }\n  }]);\n  return MultisigTransaction;\n}(txnBuilder.Transaction);\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  var refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  var refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();\n  var refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : undefined;\n  var refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(function (subsig) {\n      return subsig.pk;\n    })\n  };\n  var refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));\n  var newSubsigs = refSigTx.msig.subsig.map(function (sig) {\n    return _objectSpread({}, sig);\n  });\n  for (var i = 1; i < multisigTxnBlobs.length; i++) {\n    var unisig = encoding.decode(multisigTxnBlobs[i]);\n    var unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    var authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    var preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(function (subsig) {\n        return subsig.pk;\n      })\n    };\n    var msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach(function (uniSubsig, index) {\n      if (!uniSubsig.s) return;\n      var current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  var msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  var signedTxn = {\n    msig: msig,\n    txn: refSigTx.txn\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  var version = msig.v;\n  var threshold = msig.thr;\n  var subsigs = msig.subsig;\n  var pks = subsigs.map(function (subsig) {\n    return subsig.pk;\n  });\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  var pk;\n  try {\n    pk = address.fromMultisigPreImg({\n      version: version,\n      threshold: threshold,\n      pks: pks\n    });\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  var counter = 0;\n  var _iterator = _createForOfIteratorHelper(subsigs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var subsig = _step.value;\n      if (subsig.s !== undefined) {\n        counter += 1;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  var verifiedCounter = 0;\n  var _iterator2 = _createForOfIteratorHelper(subsigs),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _subsig = _step2.value;\n      if (_subsig.s !== undefined) {\n        if (nacl.verify(toBeVerified, _subsig.s, _subsig.pk)) {\n          verifiedCounter += 1;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(txn, _ref5, sk) {\n  var version = _ref5.version,\n    threshold = _ref5.threshold,\n    addrs = _ref5.addrs;\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  var expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version: version,\n    threshold: threshold,\n    addrs: addrs\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  var pks = addrs.map(function (addr) {\n    return address.decodeAddress(addr).publicKey;\n  });\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  var txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  var algoTxn;\n  var blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version: version,\n      threshold: threshold,\n      pks: pks\n    }, sk);\n  } else {\n    algoTxn = new MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version: version,\n      threshold: threshold,\n      pks: pks\n    }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob: blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, _ref6, sk) {\n  var version = _ref6.version,\n    threshold = _ref6.threshold,\n    addrs = _ref6.addrs;\n  var pks = addrs.map(function (addr) {\n    return address.decodeAddress(addr).publicKey;\n  });\n  // obtain underlying txn, sign it, and merge it\n  var multisigTxObj = encoding.decode(multisigTxnBlob);\n  var msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  var partialSignedBlob = msigTxn.partialSignTxn({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, _ref7, signerAddr, signature) {\n  var version = _ref7.version,\n    threshold = _ref7.threshold,\n    addrs = _ref7.addrs;\n  var pks = addrs.map(function (addr) {\n    return address.decodeAddress(addr).publicKey;\n  });\n  // obtain underlying txn, sign it, and merge it\n  var multisigTxObj = encoding.decode(multisigTxnBlob);\n  var msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  var partialSignedBlob = msigTxn.partialSignWithMultisigSignature({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  }, signerAddr, signature);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress(_ref8) {\n  var version = _ref8.version,\n    threshold = _ref8.threshold,\n    addrs = _ref8.addrs;\n  return address.fromMultisigPreImgAddrs({\n    version: version,\n    threshold: threshold,\n    addrs: addrs\n  });\n}","map":{"version":3,"names":["Buffer","nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","createMultisigTransaction","txn","_ref","version","threshold","addrs","pks","map","addr","decodeAddress","publicKey","subsigs","pk","from","msig","v","thr","subsig","txnForEncoding","get_obj_for_encoding","signedTxn","msigAddr","fromMultisigPreImg","encodeAddress","snd","sgnr","Uint8Array","encode","createMultisigTransactionWithSignature","_ref2","_ref3","rawSig","myPk","encodedMsig","decode","keyExist","forEach","i","bytesEqual","s","Error","MultisigTransaction","_txnBuilder$Transacti","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","addLease","addRekey","signTxn","sk","partialSignTxn","_ref4","keyPairFromSecretKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","from_obj_for_encoding","txnForEnc","_get","_getPrototypeOf","call","Transaction","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","undefined","refPreImage","refMsigAddr","newSubsigs","sig","_objectSpread","unisig","unisigAlgoTxn","authAddr","preimg","msgigAddr","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","_iterator","_createForOfIteratorHelper","_step","n","done","err","f","verifiedCounter","_iterator2","_step2","verify","signMultisigTransaction","_ref5","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","txnAlreadyBuilt","algoTxn","blob","toString","appendSignMultisigTransaction","multisigTxnBlob","_ref6","multisigTxObj","msigTxn","partialSignedBlob","appendSignRawMultisigSignature","_ref7","multisigAddress","_ref8"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/multisig.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\nimport AnyTransaction, { EncodedTransaction } from './types/transactions';\nimport { MultisigMetadata } from './types/multisig';\nimport {\n  EncodedMultisig,\n  EncodedSignedTransaction,\n} from './types/transactions/encoded';\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\n  'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG =\n  'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\n  'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG =\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG =\n  'Cannot add multisig signature. Signature is not of the correct length.';\n\ninterface MultisigOptions {\n  rawSig: Uint8Array;\n  myPk: Uint8Array;\n}\n\ninterface MultisigMetadataWithPks extends Omit<MultisigMetadata, 'addrs'> {\n  pks: Uint8Array[];\n}\n\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(\n  txn: txnBuilder.Transaction,\n  { version, threshold, addrs }: MultisigMetadata\n) {\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map((pk) => ({ pk: Buffer.from(pk) }));\n\n  const msig: EncodedMultisig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs,\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: txnForEncoding,\n  };\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(txnForEncoding.snd) !==\n    address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(\n  txn: txnBuilder.Transaction,\n  { rawSig, myPk }: MultisigOptions,\n  { version, threshold, pks }: MultisigMetadataWithPks\n) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map((pk) => address.encodeAddress(pk)),\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig) as EncodedSignedTransaction;\n\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  if (\n    address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)\n  ) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n\n  /**\n   * Override inherited method to throw an error, as traditional signing is not allowed\n   */\n  signTxn(sk: Uint8Array): Uint8Array; // This overload ensures that the override has a compatible type definition with the parent method\n  signTxn(sk: any): any {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn(\n    { version, threshold, pks }: MultisigMetadataWithPks,\n    sk: Uint8Array\n  ) {\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(\n      this,\n      { rawSig: this.rawSignTxn(sk), myPk },\n      { version, threshold, pks }\n    );\n  }\n\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(\n    metadata: MultisigMetadataWithPks,\n    signerAddr: string,\n    signature: Uint8Array\n  ) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(\n      this,\n      {\n        rawSig: signature,\n        myPk: address.decodeAddress(signerAddr).publicKey,\n      },\n      metadata\n    );\n  }\n\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(\n    txnForEnc: EncodedTransaction\n  ): MultisigTransaction {\n    return super.from_obj_for_encoding(txnForEnc) as MultisigTransaction;\n  }\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(\n    multisigTxnBlobs[0]\n  ) as EncodedSignedTransaction;\n  const refTxID = MultisigTransaction.from_obj_for_encoding(\n    refSigTx.txn\n  ).txID();\n  const refAuthAddr = refSigTx.sgnr\n    ? address.encodeAddress(refSigTx.sgnr)\n    : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),\n  };\n  const refMsigAddr = address.encodeAddress(\n    address.fromMultisigPreImg(refPreImage)\n  );\n\n  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(\n      multisigTxnBlobs[i]\n    ) as EncodedSignedTransaction;\n\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n\n    const authAddr = unisig.sgnr\n      ? address.encodeAddress(unisig.sgnr)\n      : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg: MultisigMetadataWithPks = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (\n        current.s &&\n        Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0\n      ) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig: EncodedMultisig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs,\n  };\n  const signedTxn: EncodedSignedTransaction = {\n    msig,\n    txn: refSigTx.txn,\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n\nexport function verifyMultisig(\n  toBeVerified: Uint8Array,\n  msig: EncodedMultisig,\n  publicKey: Uint8Array\n) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n\n  const pks = subsigs.map((subsig) => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk: Uint8Array;\n  try {\n    pk = address.fromMultisigPreImg({ version, threshold, pks });\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(\n  txn: txnBuilder.TransactionLike,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs,\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn: MultisigTransaction;\n  let blob: Uint8Array;\n  if (txnAlreadyBuilt) {\n    algoTxn = (txn as unknown) as MultisigTransaction;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(\n      algoTxn,\n      { version, threshold, pks },\n      sk\n    );\n  } else {\n    algoTxn = new MultisigTransaction(txn as AnyTransaction);\n    blob = algoTxn.partialSignTxn({ version, threshold, pks }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob,\n  };\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn(\n    { version, threshold, pks },\n    sk\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  signerAddr: string,\n  signature: Uint8Array\n) {\n  const pks = addrs.map((addr) => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(\n    multisigTxnBlob\n  ) as EncodedSignedTransaction;\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature(\n    { version, threshold, pks },\n    signerAddr,\n    signature\n  );\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs,\n}: MultisigMetadata) {\n  return address.fromMultisigPreImgAddrs({ version, threshold, addrs });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}