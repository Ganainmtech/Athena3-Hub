{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as utils from '../utils/utils';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient';\n/**\n * Remove falsy values or values with a length of 0 from an object.\n */\nfunction removeFalsyOrEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n/**\n * Create a new object with lower-case keys\n * See https://codereview.stackexchange.com/a/162418\n * Used to ensure all headers are lower-case and to work more easily with them\n */\nfunction tolowerCaseKeys(o) {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n/**\n * getAcceptFormat returns the correct Accept header depending on the\n * requested format.\n */\nfunction getAcceptFormat(query) {\n  if (query !== undefined && Object.prototype.hasOwnProperty.call(query, 'format')) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n/**\n * HTTPClient is a wrapper around a BaseHTTPClient\n * It takes care of setting the proper \"Accept\" header and of\n * decoding the JSON outputs.\n */\nexport default class HTTPClient {\n  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);\n    } else {\n      this.bc = bcOrTokenHeader;\n    }\n  }\n  /**\n   * Parse JSON using either the built-in JSON.parse or utils.parseJSON\n   * depending on whether jsonOptions are provided or not\n   *\n   * @param text - JSON data\n   * @param status - Status of the response (used in case parseJSON fails)\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   */\n  static parseJSON(text, status, jsonOptions = {}) {\n    try {\n      if (Object.keys(jsonOptions).length === 0) {\n        return text && JSON.parse(text);\n      }\n      return text && utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err = err_;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n  /**\n   * Serialize the data according to the requestHeaders\n   * Assumes that requestHeaders contain a key \"content-type\"\n   * If the content-type is \"application/json\", data is JSON serialized\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\n   * or an Uint8Array\n   * @private\n   */\n  static serializeData(data, requestHeaders) {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new Uint8Array(Buffer.from(JSON.stringify(data)));\n    }\n    if (typeof data === 'string') {\n      return new Uint8Array(Buffer.from(data));\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error('provided data is neither a string nor a Uint8Array and content-type is not application/json');\n  }\n  /**\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\n   * Parse the body in\n   * Modifies in place res and return the result\n   */\n  static prepareResponse(res, format, parseBody, jsonOptions = {}) {\n    let {\n      body\n    } = res;\n    let text;\n    if (format !== 'application/msgpack') {\n      text = body && Buffer.from(body).toString() || '';\n    }\n    if (parseBody && format === 'application/json') {\n      body = HTTPClient.parseJSON(text, res.status, jsonOptions);\n    }\n    return {\n      ...res,\n      body,\n      text,\n      ok: Math.trunc(res.status / 100) === 2\n    };\n  }\n  /**\n   * Prepare an error with a response\n   * (the type of errors BaseHTTPClient are supposed to throw)\n   * by adding the status and preparing the internal response\n   * @private\n   */\n  static prepareResponseError(err) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(err.response, 'application/json', true);\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n  /**\n   * Send a GET request.\n   * @param relativePath - The path of the request.\n   * @param query - An object containing the query parameters of the request.\n   * @param requestHeaders - An object containing additional request headers to use.\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   * @param parseBody - An optional boolean indicating whether the response body should be parsed\n   *   or not.\n   * @returns Response object.\n   */\n  async get(relativePath, query, requestHeaders = {}, jsonOptions = {}, parseBody = true) {\n    const format = getAcceptFormat(query);\n    const fullHeaders = {\n      ...requestHeaders,\n      accept: format\n    };\n    try {\n      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);\n      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a POST request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async post(relativePath, data, requestHeaders = {}, query, parseBody = true) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    try {\n      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);\n      return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a DELETE request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async delete(relativePath, data, requestHeaders = {}, parseBody = true) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), undefined, fullHeaders);\n    return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n  }\n}","map":{"version":3,"names":["Buffer","utils","URLTokenBaseHTTPClient","removeFalsyOrEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","tolowerCaseKeys","o","keys","reduce","c","k","toLowerCase","getAcceptFormat","query","undefined","format","HTTPClient","constructor","bcOrTokenHeader","baseServer","port","defaultHeaders","bc","parseJSON","text","status","jsonOptions","JSON","parse","err_","err","rawResponse","statusCode","serializeData","data","requestHeaders","Uint8Array","from","stringify","Error","prepareResponse","res","parseBody","body","toString","ok","Math","trunc","prepareResponseError","response","get","relativePath","fullHeaders","accept","post","delete"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/node_modules/algosdk/src/client/client.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as utils from '../utils/utils';\nimport {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  Query,\n} from './baseHTTPClient';\nimport { TokenHeader, URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient';\n\ninterface ErrorWithAdditionalInfo extends Error {\n  rawResponse: string | null;\n  statusCode: number;\n}\n\nexport interface HTTPClientResponse {\n  body: Uint8Array | any; // when content-type=JSON, body is a JSON object, otherwise it's a Uint8Array\n  text?: string;\n  headers: Record<string, string>;\n  status: number;\n  ok: boolean;\n}\n\n/**\n * Remove falsy values or values with a length of 0 from an object.\n */\nfunction removeFalsyOrEmpty(obj: Record<string, any>) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n\n/**\n * Create a new object with lower-case keys\n * See https://codereview.stackexchange.com/a/162418\n * Used to ensure all headers are lower-case and to work more easily with them\n */\nfunction tolowerCaseKeys(o: object): object {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce((c, k) => ((c[k.toLowerCase()] = o[k]), c), {});\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n\n/**\n * getAcceptFormat returns the correct Accept header depending on the\n * requested format.\n */\nfunction getAcceptFormat(\n  query?: Query<'msgpack' | 'json'>\n): 'application/msgpack' | 'application/json' {\n  if (\n    query !== undefined &&\n    Object.prototype.hasOwnProperty.call(query, 'format')\n  ) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n\n/**\n * HTTPClient is a wrapper around a BaseHTTPClient\n * It takes care of setting the proper \"Accept\" header and of\n * decoding the JSON outputs.\n */\nexport default class HTTPClient {\n  private bc: BaseHTTPClient;\n\n  /**\n   * Construct an HTTPClient from a BaseHTTPClient\n   * @param bc - the BaseHTTPClient used\n   */\n  constructor(bc: BaseHTTPClient);\n  /**\n   * Construct an HTTPClient from a URL (baseServer+port) and a token\n   */\n  constructor(\n    tokenHeader: TokenHeader,\n    baseServer: string,\n    port?: string | number,\n    defaultHeaders?: Record<string, string>\n  );\n\n  constructor(\n    bcOrTokenHeader: BaseHTTPClient | TokenHeader,\n    baseServer?: string,\n    port?: string | number,\n    defaultHeaders: Record<string, string> = {}\n  ) {\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(\n        bcOrTokenHeader as TokenHeader,\n        baseServer,\n        port,\n        defaultHeaders\n      );\n    } else {\n      this.bc = bcOrTokenHeader as BaseHTTPClient;\n    }\n  }\n\n  /**\n   * Parse JSON using either the built-in JSON.parse or utils.parseJSON\n   * depending on whether jsonOptions are provided or not\n   *\n   * @param text - JSON data\n   * @param status - Status of the response (used in case parseJSON fails)\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   */\n  public static parseJSON(\n    text: string,\n    status: number,\n    jsonOptions: utils.JSONOptions = {}\n  ) {\n    try {\n      if (Object.keys(jsonOptions).length === 0) {\n        return text && JSON.parse(text);\n      }\n      return text && utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err: ErrorWithAdditionalInfo = err_;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n\n  /**\n   * Serialize the data according to the requestHeaders\n   * Assumes that requestHeaders contain a key \"content-type\"\n   * If the content-type is \"application/json\", data is JSON serialized\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\n   * or an Uint8Array\n   * @private\n   */\n  private static serializeData(\n    data: object,\n    requestHeaders: Record<string, string>\n  ): Uint8Array {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new Uint8Array(Buffer.from(JSON.stringify(data)));\n    }\n    if (typeof data === 'string') {\n      return new Uint8Array(Buffer.from(data));\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error(\n      'provided data is neither a string nor a Uint8Array and content-type is not application/json'\n    );\n  }\n\n  /**\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\n   * Parse the body in\n   * Modifies in place res and return the result\n   */\n  private static prepareResponse(\n    res: BaseHTTPClientResponse,\n    format: 'application/msgpack' | 'application/json',\n    parseBody: boolean,\n    jsonOptions: utils.JSONOptions = {}\n  ): HTTPClientResponse {\n    let { body } = res;\n    let text;\n\n    if (format !== 'application/msgpack') {\n      text = (body && Buffer.from(body).toString()) || '';\n    }\n\n    if (parseBody && format === 'application/json') {\n      body = HTTPClient.parseJSON(text, res.status, jsonOptions);\n    }\n\n    return {\n      ...res,\n      body,\n      text,\n      ok: Math.trunc(res.status / 100) === 2,\n    };\n  }\n\n  /**\n   * Prepare an error with a response\n   * (the type of errors BaseHTTPClient are supposed to throw)\n   * by adding the status and preparing the internal response\n   * @private\n   */\n  private static prepareResponseError(err) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(\n        err.response,\n        'application/json',\n        true\n      );\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n\n  /**\n   * Send a GET request.\n   * @param relativePath - The path of the request.\n   * @param query - An object containing the query parameters of the request.\n   * @param requestHeaders - An object containing additional request headers to use.\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   * @param parseBody - An optional boolean indicating whether the response body should be parsed\n   *   or not.\n   * @returns Response object.\n   */\n  async get(\n    relativePath: string,\n    query?: Query<any>,\n    requestHeaders: Record<string, string> = {},\n    jsonOptions: utils.JSONOptions = {},\n    parseBody: boolean = true\n  ): Promise<HTTPClientResponse> {\n    const format = getAcceptFormat(query);\n    const fullHeaders = { ...requestHeaders, accept: format };\n\n    try {\n      const res = await this.bc.get(\n        relativePath,\n        removeFalsyOrEmpty(query),\n        fullHeaders\n      );\n\n      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n\n  /**\n   * Send a POST request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async post(\n    relativePath: string,\n    data: any,\n    requestHeaders: Record<string, string> = {},\n    query?: Query<any>,\n    parseBody: boolean = true\n  ): Promise<HTTPClientResponse> {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders),\n    };\n\n    try {\n      const res = await this.bc.post(\n        relativePath,\n        HTTPClient.serializeData(data, fullHeaders),\n        query,\n        fullHeaders\n      );\n\n      return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n\n  /**\n   * Send a DELETE request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async delete(\n    relativePath: string,\n    data: any,\n    requestHeaders: Record<string, string> = {},\n    parseBody: boolean = true\n  ) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders),\n    };\n\n    const res = await this.bc.delete(\n      relativePath,\n      HTTPClient.serializeData(data, fullHeaders),\n      undefined,\n      fullHeaders\n    );\n\n    return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}