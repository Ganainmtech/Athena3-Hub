{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { Application, ApplicationParams, ApplicationStateSchema, DryrunRequest } from './client/v2/algod/models/types';\nimport { TransactionType } from './types/transactions';\nimport { encodeAddress, getApplicationAddress } from './encoding/address';\nconst defaultAppId = 1380011588;\nconst defaultMaxWidth = 30;\nfunction decodePrograms(ap) {\n  // eslint-disable-next-line no-param-reassign\n  ap.params['approval-program'] = Buffer.from(ap.params['approval-program'].toString(), 'base64');\n  // eslint-disable-next-line no-param-reassign\n  ap.params['clear-state-program'] = Buffer.from(ap.params['clear-state-program'].toString(), 'base64');\n  return ap;\n}\n/**\n * createDryrun takes an Algod Client (from algod.AlgodV2Client) and an array of Signed Transactions\n * from (transaction.SignedTransaction) and creates a DryrunRequest object with relevant balances\n * @param client - the AlgodClient to make requests against\n * @param txns - the array of SignedTransaction to use for generating the DryrunRequest object\n * @param protocolVersion - the string representing the protocol version to use\n * @param latestTimestamp - the timestamp\n * @returns the DryrunRequest object constructed from the SignedTransactions passed\n */\nexport async function createDryrun({\n  client,\n  txns,\n  protocolVersion,\n  latestTimestamp,\n  round,\n  sources\n}) {\n  const appInfos = [];\n  const acctInfos = [];\n  const apps = [];\n  const assets = [];\n  const accts = [];\n  for (const t of txns) {\n    if (t.txn.type === TransactionType.appl) {\n      accts.push(encodeAddress(t.txn.from.publicKey));\n      if (t.txn.appAccounts) accts.push(...t.txn.appAccounts.map(a => encodeAddress(a.publicKey)));\n      if (t.txn.appForeignApps) {\n        apps.push(...t.txn.appForeignApps);\n        accts.push(...t.txn.appForeignApps.map(aidx => getApplicationAddress(aidx)));\n      }\n      if (t.txn.appForeignAssets) assets.push(...t.txn.appForeignAssets);\n      // Create application,\n      if (t.txn.appIndex === undefined || t.txn.appIndex === 0) {\n        appInfos.push(new Application({\n          id: defaultAppId,\n          params: new ApplicationParams({\n            creator: encodeAddress(t.txn.from.publicKey),\n            approvalProgram: t.txn.appApprovalProgram,\n            clearStateProgram: t.txn.appClearProgram,\n            localStateSchema: new ApplicationStateSchema({\n              numUint: t.txn.appLocalInts,\n              numByteSlice: t.txn.appLocalByteSlices\n            }),\n            globalStateSchema: new ApplicationStateSchema({\n              numUint: t.txn.appGlobalInts,\n              numByteSlice: t.txn.appGlobalByteSlices\n            })\n          })\n        }));\n      } else {\n        apps.push(t.txn.appIndex);\n        accts.push(getApplicationAddress(t.txn.appIndex));\n      }\n    }\n  }\n  // Dedupe and add creator to accts array\n  const assetPromises = [];\n  for (const assetId of [...new Set(assets)]) {\n    assetPromises.push(client.getAssetByID(assetId).do().then(assetInfo => {\n      accts.push(assetInfo.params.creator);\n    }));\n  }\n  // Wait for assets to finish since we append to accts array\n  await Promise.all(assetPromises);\n  // Dedupe and get app info for all apps\n  const appPromises = [];\n  for (const appId of [...new Set(apps)]) {\n    appPromises.push(client.getApplicationByID(appId).do().then(appInfo => {\n      const ai = decodePrograms(appInfo);\n      appInfos.push(ai);\n      accts.push(ai.params.creator);\n    }));\n  }\n  await Promise.all(appPromises);\n  const acctPromises = [];\n  for (const acct of [...new Set(accts)]) {\n    acctPromises.push(client.accountInformation(acct).do().then(acctInfo => {\n      if ('created-apps' in acctInfo) {\n        // eslint-disable-next-line no-param-reassign\n        acctInfo['created-apps'] = acctInfo['created-apps'].map(app => decodePrograms(app));\n      }\n      acctInfos.push(acctInfo);\n    }));\n  }\n  await Promise.all(acctPromises);\n  return new DryrunRequest({\n    txns: txns.map(st => ({\n      ...st,\n      txn: st.txn.get_obj_for_encoding()\n    })),\n    accounts: acctInfos,\n    apps: appInfos,\n    latestTimestamp,\n    round,\n    protocolVersion,\n    sources\n  });\n}\nclass DryrunStackValue {\n  constructor(sv) {\n    this.type = 0;\n    this.bytes = '';\n    this.uint = 0;\n    this.type = sv.type;\n    this.bytes = sv.bytes;\n    this.uint = sv.uint;\n  }\n  toString() {\n    if (this.type === 1) {\n      return `0x${Buffer.from(this.bytes, 'base64').toString('hex')}`;\n    }\n    return this.uint.toString();\n  }\n}\nclass DryrunTraceLine {\n  constructor(line) {\n    this.error = '';\n    this.line = 0;\n    this.pc = 0;\n    this.scratch = [];\n    this.stack = [];\n    this.error = line.error === undefined ? '' : line.error;\n    this.line = line.line;\n    this.pc = line.pc;\n    this.scratch = line.scratch;\n    this.stack = line.stack.map(sv => new DryrunStackValue(sv));\n  }\n}\nclass DryrunTrace {\n  constructor(t) {\n    this.trace = [];\n    if (t == null) return;\n    this.trace = t.map(line => new DryrunTraceLine(line));\n  }\n}\nfunction truncate(str, maxValueWidth) {\n  if (str.length > maxValueWidth && maxValueWidth > 0) {\n    return `${str.slice(0, maxValueWidth)}...`;\n  }\n  return str;\n}\nfunction scratchToString(prevScratch, currScratch) {\n  if (currScratch.length === 0) return '';\n  let newScratchIdx = null;\n  for (let idx = 0; idx < currScratch.length; idx++) {\n    if (idx > prevScratch.length) {\n      newScratchIdx = idx;\n      continue;\n    }\n    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {\n      newScratchIdx = idx;\n    }\n  }\n  if (newScratchIdx == null) return '';\n  const newScratch = currScratch[newScratchIdx];\n  if (newScratch.bytes.length > 0) {\n    return `${newScratchIdx} = 0x${Buffer.from(newScratch.bytes, 'base64').toString('hex')}`;\n  }\n  return `${newScratchIdx} = ${newScratch.uint.toString()}`;\n}\nfunction stackToString(stack, reverse) {\n  const svs = reverse ? stack.reverse() : stack;\n  return `[${svs.map(sv => {\n    switch (sv.type) {\n      case 1:\n        return `0x${Buffer.from(sv.bytes, 'base64').toString('hex')}`;\n      case 2:\n        return `${sv.uint.toString()}`;\n      default:\n        return '';\n    }\n  }).join(', ')}]`;\n}\nclass DryrunTransactionResult {\n  constructor(dtr) {\n    this.disassembly = [];\n    this.appCallMessages = [];\n    this.localDeltas = [];\n    this.globalDelta = [];\n    this.cost = 0;\n    this.logicSigMessages = [];\n    this.logicSigDisassembly = [];\n    this.logs = [];\n    this.appCallTrace = undefined;\n    this.logicSigTrace = undefined;\n    this.required = ['disassembly'];\n    this.optionals = ['app-call-messages', 'local-deltas', 'global-delta', 'cost', 'logic-sig-messages', 'logic-sig-disassembly', 'logs'];\n    this.traces = ['app-call-trace', 'logic-sig-trace'];\n    this.disassembly = dtr.disassembly;\n    this.appCallMessages = dtr['app-call-messages'];\n    this.localDeltas = dtr['local-deltas'];\n    this.globalDelta = dtr['global-delta'];\n    this.cost = dtr.cost;\n    this.logicSigMessages = dtr['logic-sig-messages'];\n    this.logicSigDisassembly = dtr['logic-sig-disassembly'];\n    this.logs = dtr.logs;\n    this.appCallTrace = new DryrunTrace(dtr['app-call-trace']);\n    this.logicSigTrace = new DryrunTrace(dtr['logic-sig-trace']);\n  }\n  appCallRejected() {\n    return this.appCallMessages !== undefined && this.appCallMessages.includes('REJECT');\n  }\n  logicSigRejected() {\n    return this.logicSigMessages !== undefined && this.logicSigMessages.includes('REJECT');\n  }\n  static trace(drt, disassembly, spc) {\n    const maxWidth = spc.maxValueWidth || defaultMaxWidth;\n    // Create the array of arrays, each sub array contains N columns\n    const lines = [['pc#', 'ln#', 'source', 'scratch', 'stack']];\n    for (let idx = 0; idx < drt.trace.length; idx++) {\n      const {\n        line,\n        error,\n        pc,\n        scratch,\n        stack\n      } = drt.trace[idx];\n      const currScratch = scratch !== undefined ? scratch : [];\n      const prevScratch = idx > 0 && drt.trace[idx - 1].scratch !== undefined ? drt.trace[idx - 1].scratch : [];\n      const src = error === '' ? disassembly[line] : `!! ${error} !!`;\n      lines.push([pc.toString().padEnd(3, ' '), line.toString().padEnd(3, ' '), truncate(src, maxWidth), truncate(scratchToString(prevScratch, currScratch), maxWidth), truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)]);\n    }\n    // Get the max length for each column\n    const maxLengths = lines.reduce((prev, curr) => {\n      const newVal = new Array(lines[0].length).fill(0);\n      for (let idx = 0; idx < prev.length; idx++) {\n        newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];\n      }\n      return newVal;\n    }, new Array(lines[0].length).fill(0));\n    return `${lines.map(line => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, ' ')).join('|').trim()).join('\\n')}\\n`;\n  }\n  appTrace(spc) {\n    if (this.appCallTrace === undefined || !this.disassembly) return '';\n    let conf = spc;\n    if (spc === undefined) conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: false\n    };\n    return DryrunTransactionResult.trace(this.appCallTrace, this.disassembly, conf);\n  }\n  lsigTrace(spc) {\n    if (this.logicSigTrace === undefined || this.logicSigDisassembly === undefined) return '';\n    let conf = spc;\n    if (spc === undefined) conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: true\n    };\n    return DryrunTransactionResult.trace(this.logicSigTrace, this.logicSigDisassembly, conf);\n  }\n}\nexport class DryrunResult {\n  constructor(drrResp) {\n    this.error = '';\n    this.protocolVersion = '';\n    this.txns = [];\n    this.error = drrResp.error;\n    this.protocolVersion = drrResp['protocol-version'];\n    this.txns = drrResp.txns.map(txn => new DryrunTransactionResult(txn));\n  }\n}","map":{"version":3,"names":["Buffer","Application","ApplicationParams","ApplicationStateSchema","DryrunRequest","TransactionType","encodeAddress","getApplicationAddress","defaultAppId","defaultMaxWidth","decodePrograms","ap","params","from","toString","createDryrun","client","txns","protocolVersion","latestTimestamp","round","sources","appInfos","acctInfos","apps","assets","accts","t","txn","type","appl","push","publicKey","appAccounts","map","a","appForeignApps","aidx","appForeignAssets","appIndex","undefined","id","creator","approvalProgram","appApprovalProgram","clearStateProgram","appClearProgram","localStateSchema","numUint","appLocalInts","numByteSlice","appLocalByteSlices","globalStateSchema","appGlobalInts","appGlobalByteSlices","assetPromises","assetId","Set","getAssetByID","do","then","assetInfo","Promise","all","appPromises","appId","getApplicationByID","appInfo","ai","acctPromises","acct","accountInformation","acctInfo","app","st","get_obj_for_encoding","accounts","DryrunStackValue","constructor","sv","bytes","uint","DryrunTraceLine","line","error","pc","scratch","stack","DryrunTrace","trace","truncate","str","maxValueWidth","length","slice","scratchToString","prevScratch","currScratch","newScratchIdx","idx","JSON","stringify","newScratch","stackToString","reverse","svs","join","DryrunTransactionResult","dtr","disassembly","appCallMessages","localDeltas","globalDelta","cost","logicSigMessages","logicSigDisassembly","logs","appCallTrace","logicSigTrace","required","optionals","traces","appCallRejected","includes","logicSigRejected","drt","spc","maxWidth","lines","src","padEnd","topOfStackFirst","maxLengths","reduce","prev","curr","newVal","Array","fill","v","trim","appTrace","conf","lsigTrace","DryrunResult","drrResp"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/node_modules/algosdk/src/dryrun.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport AlgodClient from './client/v2/algod/algod';\nimport {\n  AccountStateDelta,\n  Application,\n  ApplicationParams,\n  ApplicationStateSchema,\n  DryrunRequest,\n  DryrunSource,\n  EvalDeltaKeyValue,\n  TealValue,\n} from './client/v2/algod/models/types';\nimport { SignedTransaction } from './transaction';\nimport { TransactionType } from './types/transactions';\nimport { encodeAddress, getApplicationAddress } from './encoding/address';\n\nconst defaultAppId = 1380011588;\nconst defaultMaxWidth = 30;\n\n// When writing the DryrunRequest object as msgpack the output needs to be the byte arrays not b64 string\ninterface AppParamsWithPrograms {\n  ['approval-program']: string | Uint8Array;\n  ['clear-state-program']: string | Uint8Array;\n  ['creator']: string;\n}\n\ninterface AppWithAppParams {\n  ['params']: AppParamsWithPrograms;\n}\n\nfunction decodePrograms(ap: AppWithAppParams): AppWithAppParams {\n  // eslint-disable-next-line no-param-reassign\n  ap.params['approval-program'] = Buffer.from(\n    ap.params['approval-program'].toString(),\n    'base64'\n  );\n  // eslint-disable-next-line no-param-reassign\n  ap.params['clear-state-program'] = Buffer.from(\n    ap.params['clear-state-program'].toString(),\n    'base64'\n  );\n\n  return ap;\n}\n\n/**\n * createDryrun takes an Algod Client (from algod.AlgodV2Client) and an array of Signed Transactions\n * from (transaction.SignedTransaction) and creates a DryrunRequest object with relevant balances\n * @param client - the AlgodClient to make requests against\n * @param txns - the array of SignedTransaction to use for generating the DryrunRequest object\n * @param protocolVersion - the string representing the protocol version to use\n * @param latestTimestamp - the timestamp\n * @returns the DryrunRequest object constructed from the SignedTransactions passed\n */\nexport async function createDryrun({\n  client,\n  txns,\n  protocolVersion,\n  latestTimestamp,\n  round,\n  sources,\n}: {\n  client: AlgodClient;\n  txns: SignedTransaction[];\n  protocolVersion?: string;\n  latestTimestamp?: number | bigint;\n  round?: number | bigint;\n  sources?: DryrunSource[];\n}): Promise<DryrunRequest> {\n  const appInfos = [];\n  const acctInfos = [];\n\n  const apps: number[] = [];\n  const assets: number[] = [];\n  const accts: string[] = [];\n\n  for (const t of txns) {\n    if (t.txn.type === TransactionType.appl) {\n      accts.push(encodeAddress(t.txn.from.publicKey));\n\n      if (t.txn.appAccounts)\n        accts.push(...t.txn.appAccounts.map((a) => encodeAddress(a.publicKey)));\n\n      if (t.txn.appForeignApps) {\n        apps.push(...t.txn.appForeignApps);\n        accts.push(\n          ...t.txn.appForeignApps.map((aidx) => getApplicationAddress(aidx))\n        );\n      }\n\n      if (t.txn.appForeignAssets) assets.push(...t.txn.appForeignAssets);\n\n      // Create application,\n      if (t.txn.appIndex === undefined || t.txn.appIndex === 0) {\n        appInfos.push(\n          new Application({\n            id: defaultAppId,\n            params: new ApplicationParams({\n              creator: encodeAddress(t.txn.from.publicKey),\n              approvalProgram: t.txn.appApprovalProgram,\n              clearStateProgram: t.txn.appClearProgram,\n              localStateSchema: new ApplicationStateSchema({\n                numUint: t.txn.appLocalInts,\n                numByteSlice: t.txn.appLocalByteSlices,\n              }),\n              globalStateSchema: new ApplicationStateSchema({\n                numUint: t.txn.appGlobalInts,\n                numByteSlice: t.txn.appGlobalByteSlices,\n              }),\n            }),\n          })\n        );\n      } else {\n        apps.push(t.txn.appIndex);\n        accts.push(getApplicationAddress(t.txn.appIndex));\n      }\n    }\n  }\n\n  // Dedupe and add creator to accts array\n  const assetPromises = [];\n  for (const assetId of [...new Set(assets)]) {\n    assetPromises.push(\n      client\n        .getAssetByID(assetId)\n        .do()\n        .then((assetInfo) => {\n          accts.push(assetInfo.params.creator);\n        })\n    );\n  }\n  // Wait for assets to finish since we append to accts array\n  await Promise.all(assetPromises);\n\n  // Dedupe and get app info for all apps\n  const appPromises = [];\n  for (const appId of [...new Set(apps)]) {\n    appPromises.push(\n      client\n        .getApplicationByID(appId)\n        .do()\n        .then((appInfo) => {\n          const ai = decodePrograms(appInfo as AppWithAppParams);\n          appInfos.push(ai);\n          accts.push(ai.params.creator);\n        })\n    );\n  }\n  await Promise.all(appPromises);\n\n  const acctPromises = [];\n  for (const acct of [...new Set(accts)]) {\n    acctPromises.push(\n      client\n        .accountInformation(acct)\n        .do()\n        .then((acctInfo) => {\n          if ('created-apps' in acctInfo) {\n            // eslint-disable-next-line no-param-reassign\n            acctInfo['created-apps'] = acctInfo['created-apps'].map((app) =>\n              decodePrograms(app)\n            );\n          }\n          acctInfos.push(acctInfo);\n        })\n    );\n  }\n  await Promise.all(acctPromises);\n\n  return new DryrunRequest({\n    txns: txns.map((st) => ({ ...st, txn: st.txn.get_obj_for_encoding() })),\n    accounts: acctInfos,\n    apps: appInfos,\n    latestTimestamp,\n    round,\n    protocolVersion,\n    sources,\n  });\n}\n\ninterface StackValueResponse {\n  type: number;\n  bytes: string;\n  uint: number;\n}\n\nclass DryrunStackValue {\n  type: number = 0;\n  bytes: string = '';\n  uint: number = 0;\n\n  constructor(sv: StackValueResponse) {\n    this.type = sv.type;\n    this.bytes = sv.bytes;\n    this.uint = sv.uint;\n  }\n\n  toString(): string {\n    if (this.type === 1) {\n      return `0x${Buffer.from(this.bytes, 'base64').toString('hex')}`;\n    }\n    return this.uint.toString();\n  }\n}\n\ninterface DryrunTraceLineResponse {\n  error: string;\n  line: number;\n  pc: number;\n  scratch: TealValue[];\n  stack: StackValueResponse[];\n}\n\nclass DryrunTraceLine {\n  error: string = '';\n  line: number = 0;\n  pc: number = 0;\n  scratch: TealValue[] = [];\n  stack: DryrunStackValue[] = [];\n\n  constructor(line: DryrunTraceLineResponse) {\n    this.error = line.error === undefined ? '' : line.error;\n    this.line = line.line;\n    this.pc = line.pc;\n    this.scratch = line.scratch;\n    this.stack = line.stack.map(\n      (sv: StackValueResponse) => new DryrunStackValue(sv)\n    );\n  }\n}\n\nclass DryrunTrace {\n  trace: DryrunTraceLine[] = [];\n  constructor(t: DryrunTraceLineResponse[]) {\n    if (t == null) return;\n    this.trace = t.map((line) => new DryrunTraceLine(line));\n  }\n}\n\ninterface DryrunTransactionResultResponse {\n  disassembly: string[];\n  appCallMessages: string[] | undefined;\n  localDeltas: AccountStateDelta[] | undefined;\n  globalDelta: EvalDeltaKeyValue[] | undefined;\n  cost: number | undefined;\n  logicSigMessages: string[] | undefined;\n  logicSigDisassembly: string[] | undefined;\n  logs: string[] | undefined;\n  appCallTrace: DryrunTrace | undefined;\n  logicSigTrace: DryrunTrace | undefined;\n}\n\ninterface StackPrinterConfig {\n  maxValueWidth: number | undefined;\n  topOfStackFirst: boolean | undefined;\n}\n\nfunction truncate(str: string, maxValueWidth: number): string {\n  if (str.length > maxValueWidth && maxValueWidth > 0) {\n    return `${str.slice(0, maxValueWidth)}...`;\n  }\n  return str;\n}\n\nfunction scratchToString(\n  prevScratch: TealValue[],\n  currScratch: TealValue[]\n): string {\n  if (currScratch.length === 0) return '';\n\n  let newScratchIdx = null;\n  for (let idx = 0; idx < currScratch.length; idx++) {\n    if (idx > prevScratch.length) {\n      newScratchIdx = idx;\n      continue;\n    }\n\n    if (JSON.stringify(prevScratch[idx]) !== JSON.stringify(currScratch[idx])) {\n      newScratchIdx = idx;\n    }\n  }\n\n  if (newScratchIdx == null) return '';\n\n  const newScratch = currScratch[newScratchIdx];\n  if (newScratch.bytes.length > 0) {\n    return `${newScratchIdx} = 0x${Buffer.from(\n      newScratch.bytes,\n      'base64'\n    ).toString('hex')}`;\n  }\n  return `${newScratchIdx} = ${newScratch.uint.toString()}`;\n}\n\nfunction stackToString(stack: DryrunStackValue[], reverse: boolean): string {\n  const svs = reverse ? stack.reverse() : stack;\n  return `[${svs\n    .map((sv: DryrunStackValue) => {\n      switch (sv.type) {\n        case 1:\n          return `0x${Buffer.from(sv.bytes, 'base64').toString('hex')}`;\n        case 2:\n          return `${sv.uint.toString()}`;\n        default:\n          return '';\n      }\n    })\n    .join(', ')}]`;\n}\n\nclass DryrunTransactionResult {\n  disassembly: string[] = [];\n  appCallMessages: string[] | undefined = [];\n  localDeltas: AccountStateDelta[] | undefined = [];\n  globalDelta: EvalDeltaKeyValue[] | undefined = [];\n  cost: number | undefined = 0;\n  logicSigMessages: string[] | undefined = [];\n  logicSigDisassembly: string[] | undefined = [];\n  logs: string[] | undefined = [];\n\n  appCallTrace: DryrunTrace | undefined = undefined;\n  logicSigTrace: DryrunTrace | undefined = undefined;\n\n  required = ['disassembly'];\n  optionals = [\n    'app-call-messages',\n    'local-deltas',\n    'global-delta',\n    'cost',\n    'logic-sig-messages',\n    'logic-sig-disassembly',\n    'logs',\n  ];\n\n  traces = ['app-call-trace', 'logic-sig-trace'];\n\n  constructor(dtr: DryrunTransactionResultResponse) {\n    this.disassembly = dtr.disassembly;\n    this.appCallMessages = dtr['app-call-messages'];\n    this.localDeltas = dtr['local-deltas'];\n    this.globalDelta = dtr['global-delta'];\n    this.cost = dtr.cost;\n    this.logicSigMessages = dtr['logic-sig-messages'];\n    this.logicSigDisassembly = dtr['logic-sig-disassembly'];\n    this.logs = dtr.logs;\n    this.appCallTrace = new DryrunTrace(dtr['app-call-trace']);\n    this.logicSigTrace = new DryrunTrace(dtr['logic-sig-trace']);\n  }\n\n  appCallRejected(): boolean {\n    return (\n      this.appCallMessages !== undefined &&\n      this.appCallMessages.includes('REJECT')\n    );\n  }\n\n  logicSigRejected(): boolean {\n    return (\n      this.logicSigMessages !== undefined &&\n      this.logicSigMessages.includes('REJECT')\n    );\n  }\n\n  static trace(\n    drt: DryrunTrace,\n    disassembly: string[],\n    spc: StackPrinterConfig\n  ): string {\n    const maxWidth = spc.maxValueWidth || defaultMaxWidth;\n\n    // Create the array of arrays, each sub array contains N columns\n    const lines = [['pc#', 'ln#', 'source', 'scratch', 'stack']];\n    for (let idx = 0; idx < drt.trace.length; idx++) {\n      const { line, error, pc, scratch, stack } = drt.trace[idx];\n\n      const currScratch = scratch !== undefined ? scratch : [];\n      const prevScratch =\n        idx > 0 && drt.trace[idx - 1].scratch !== undefined\n          ? drt.trace[idx - 1].scratch\n          : [];\n\n      const src = error === '' ? disassembly[line] : `!! ${error} !!`;\n\n      lines.push([\n        pc.toString().padEnd(3, ' '),\n        line.toString().padEnd(3, ' '),\n        truncate(src, maxWidth),\n        truncate(scratchToString(prevScratch, currScratch), maxWidth),\n        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth),\n      ]);\n    }\n\n    // Get the max length for each column\n    const maxLengths = lines.reduce((prev, curr) => {\n      const newVal = new Array(lines[0].length).fill(0);\n      for (let idx = 0; idx < prev.length; idx++) {\n        newVal[idx] =\n          curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];\n      }\n      return newVal;\n    }, new Array(lines[0].length).fill(0));\n\n    return `${lines\n      .map((line) =>\n        line\n          .map((v, idx) => v.padEnd(maxLengths[idx] + 1, ' '))\n          .join('|')\n          .trim()\n      )\n      .join('\\n')}\\n`;\n  }\n\n  appTrace(spc?: StackPrinterConfig): string {\n    if (this.appCallTrace === undefined || !this.disassembly) return '';\n\n    let conf = spc;\n    if (spc === undefined)\n      conf = {\n        maxValueWidth: defaultMaxWidth,\n        topOfStackFirst: false,\n      } as StackPrinterConfig;\n\n    return DryrunTransactionResult.trace(\n      this.appCallTrace,\n      this.disassembly,\n      conf\n    );\n  }\n\n  lsigTrace(spc?: StackPrinterConfig): string {\n    if (\n      this.logicSigTrace === undefined ||\n      this.logicSigDisassembly === undefined\n    )\n      return '';\n\n    let conf = spc;\n    if (spc === undefined)\n      conf = {\n        maxValueWidth: defaultMaxWidth,\n        topOfStackFirst: true,\n      } as StackPrinterConfig;\n\n    return DryrunTransactionResult.trace(\n      this.logicSigTrace,\n      this.logicSigDisassembly,\n      conf\n    );\n  }\n}\n\ninterface DryrunResultResponse {\n  ['error']: string;\n  ['protocol-version']: string;\n  ['txns']: DryrunTransactionResultResponse[];\n}\n\nexport class DryrunResult {\n  error: string = '';\n  protocolVersion: string = '';\n  txns: DryrunTransactionResult[] = [];\n  constructor(drrResp: DryrunResultResponse) {\n    this.error = drrResp.error;\n    this.protocolVersion = drrResp['protocol-version'];\n    this.txns = drrResp.txns.map(\n      (txn: DryrunTransactionResultResponse) => new DryrunTransactionResult(txn)\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}