{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Buffer } from 'buffer';\nimport { ABIAddressType, abiCheckTransactionType, ABIReferenceType, ABITupleType, abiTypeIsReference, abiTypeIsTransaction, ABIUintType } from './abi';\nimport { SimulateRequest, SimulateRequestTransactionGroup } from './client/v2/algod/models/types';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport { isTransactionWithSigner } from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport { OnApplicationComplete } from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\nimport * as encoding from './encoding/encoding';\n// First 4 bytes of SHA-512/256 hash of \"return\"\nvar RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n// The maximum number of arguments for an application call transaction\nvar MAX_APP_ARGS = 16;\nexport var AtomicTransactionComposerStatus;\n(function (AtomicTransactionComposerStatus) {\n  /** The atomic group is still under construction. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILDING\"] = 0] = \"BUILDING\";\n  /** The atomic group has been finalized, but not yet signed. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILT\"] = 1] = \"BUILT\";\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SIGNED\"] = 2] = \"SIGNED\";\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SUBMITTED\"] = 3] = \"SUBMITTED\";\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"COMMITTED\"] = 4] = \"COMMITTED\";\n})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray(valueToAdd, array, zeroValue) {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n  var offset = zeroValue == null ? 0 : 1;\n  for (var i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n/** A class used to construct and execute atomic transaction groups */\nexport var AtomicTransactionComposer = /*#__PURE__*/function () {\n  function AtomicTransactionComposer() {\n    _classCallCheck(this, AtomicTransactionComposer);\n    this.status = AtomicTransactionComposerStatus.BUILDING;\n    this.transactions = [];\n    this.methodCalls = new Map();\n    this.signedTxns = [];\n    this.txIDs = [];\n  }\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  _createClass(AtomicTransactionComposer, [{\n    key: \"getStatus\",\n    value: function getStatus() {\n      return this.status;\n    }\n    /**\n     * Get the number of transactions currently in this atomic group.\n     */\n  }, {\n    key: \"count\",\n    value: function count() {\n      return this.transactions.length;\n    }\n    /**\n     * Create a new composer with the same underlying transactions. The new composer's status will be\n     * BUILDING, so additional transactions may be added to it.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var theClone = new AtomicTransactionComposer();\n      theClone.transactions = this.transactions.map(function (_ref) {\n        var txn = _ref.txn,\n          signer = _ref.signer;\n        return {\n          // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n          txn: Transaction.from_obj_for_encoding(_objectSpread(_objectSpread({}, txn.get_obj_for_encoding()), {}, {\n            // erase the group ID\n            grp: undefined\n          })),\n          signer: signer\n        };\n      });\n      theClone.methodCalls = new Map(this.methodCalls);\n      return theClone;\n    }\n    /**\n     * Add a transaction to this atomic group.\n     *\n     * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n     * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n     */\n  }, {\n    key: \"addTransaction\",\n    value: function addTransaction(txnAndSigner) {\n      if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n        throw new Error('Cannot add transactions when composer status is not BUILDING');\n      }\n      if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n        throw new Error(\"Adding an additional transaction exceeds the maximum atomic group size of \".concat(AtomicTransactionComposer.MAX_GROUP_SIZE));\n      }\n      if (txnAndSigner.txn.group && txnAndSigner.txn.group.some(function (v) {\n        return v !== 0;\n      })) {\n        throw new Error('Cannot add a transaction with nonzero group ID');\n      }\n      this.transactions.push(txnAndSigner);\n    }\n    /**\n     * Add a smart contract method call to this atomic group.\n     *\n     * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n     * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n     * for the given method.\n     */\n  }, {\n    key: \"addMethodCall\",\n    value: function addMethodCall(_ref2) {\n      var _this$transactions;\n      var appID = _ref2.appID,\n        method = _ref2.method,\n        methodArgs = _ref2.methodArgs,\n        sender = _ref2.sender,\n        suggestedParams = _ref2.suggestedParams,\n        onComplete = _ref2.onComplete,\n        approvalProgram = _ref2.approvalProgram,\n        clearProgram = _ref2.clearProgram,\n        numGlobalInts = _ref2.numGlobalInts,\n        numGlobalByteSlices = _ref2.numGlobalByteSlices,\n        numLocalInts = _ref2.numLocalInts,\n        numLocalByteSlices = _ref2.numLocalByteSlices,\n        extraPages = _ref2.extraPages,\n        appAccounts = _ref2.appAccounts,\n        appForeignApps = _ref2.appForeignApps,\n        appForeignAssets = _ref2.appForeignAssets,\n        boxes = _ref2.boxes,\n        note = _ref2.note,\n        lease = _ref2.lease,\n        rekeyTo = _ref2.rekeyTo,\n        signer = _ref2.signer;\n      if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n        throw new Error('Cannot add transactions when composer status is not BUILDING');\n      }\n      if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {\n        throw new Error(\"Adding additional transactions exceeds the maximum atomic group size of \".concat(AtomicTransactionComposer.MAX_GROUP_SIZE));\n      }\n      if (appID === 0) {\n        if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {\n          throw new Error('One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices');\n        }\n      } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n        if (approvalProgram == null || clearProgram == null) {\n          throw new Error('One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram');\n        }\n        if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n          throw new Error('One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n        }\n      } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n        throw new Error('One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n      }\n      if (methodArgs == null) {\n        // eslint-disable-next-line no-param-reassign\n        methodArgs = [];\n      }\n      if (methodArgs.length !== method.args.length) {\n        throw new Error(\"Incorrect number of method arguments. Expected \".concat(method.args.length, \", got \").concat(methodArgs.length));\n      }\n      var basicArgTypes = [];\n      var basicArgValues = [];\n      var txnArgs = [];\n      var refArgTypes = [];\n      var refArgValues = [];\n      var refArgIndexToBasicArgIndex = new Map();\n      // TODO: Box encoding for ABI\n      var boxReferences = !boxes ? [] : boxes;\n      for (var i = 0; i < methodArgs.length; i++) {\n        var argType = method.args[i].type;\n        var argValue = methodArgs[i];\n        if (abiTypeIsTransaction(argType)) {\n          if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {\n            throw new Error(\"Expected \".concat(argType, \" TransactionWithSigner for argument at index \").concat(i));\n          }\n          if (argValue.txn.group && argValue.txn.group.some(function (v) {\n            return v !== 0;\n          })) {\n            throw new Error('Cannot add a transaction with nonzero group ID');\n          }\n          txnArgs.push(argValue);\n          continue;\n        }\n        if (isTransactionWithSigner(argValue)) {\n          throw new Error(\"Expected non-transaction value for argument at index \".concat(i));\n        }\n        if (abiTypeIsReference(argType)) {\n          refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);\n          refArgTypes.push(argType);\n          refArgValues.push(argValue);\n          // treat the reference as a uint8 for encoding purposes\n          argType = new ABIUintType(8);\n        }\n        if (typeof argType === 'string') {\n          throw new Error(\"Unknown ABI type: \".concat(argType));\n        }\n        basicArgTypes.push(argType);\n        basicArgValues.push(argValue);\n      }\n      var resolvedRefIndexes = [];\n      var foreignAccounts = appAccounts == null ? [] : appAccounts.slice();\n      var foreignApps = appForeignApps == null ? [] : appForeignApps.slice();\n      var foreignAssets = appForeignAssets == null ? [] : appForeignAssets.slice();\n      for (var _i = 0; _i < refArgTypes.length; _i++) {\n        var refType = refArgTypes[_i];\n        var refValue = refArgValues[_i];\n        var resolved = 0;\n        switch (refType) {\n          case ABIReferenceType.account:\n            {\n              var addressType = new ABIAddressType();\n              var address = addressType.decode(addressType.encode(refValue));\n              resolved = populateForeignArray(address, foreignAccounts, sender);\n              break;\n            }\n          case ABIReferenceType.application:\n            {\n              var uint64Type = new ABIUintType(64);\n              var refAppID = uint64Type.decode(uint64Type.encode(refValue));\n              if (refAppID > Number.MAX_SAFE_INTEGER) {\n                throw new Error(\"Expected safe integer for application value, got \".concat(refAppID));\n              }\n              resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n              break;\n            }\n          case ABIReferenceType.asset:\n            {\n              var _uint64Type = new ABIUintType(64);\n              var refAssetID = _uint64Type.decode(_uint64Type.encode(refValue));\n              if (refAssetID > Number.MAX_SAFE_INTEGER) {\n                throw new Error(\"Expected safe integer for asset value, got \".concat(refAssetID));\n              }\n              resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n              break;\n            }\n          default:\n            throw new Error(\"Unknown reference type: \".concat(refType));\n        }\n        resolvedRefIndexes.push(resolved);\n      }\n      for (var _i2 = 0; _i2 < resolvedRefIndexes.length; _i2++) {\n        var basicArgIndex = refArgIndexToBasicArgIndex.get(_i2);\n        basicArgValues[basicArgIndex] = resolvedRefIndexes[_i2];\n      }\n      if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n        var lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n        var lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n        basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n        basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n        basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n        basicArgValues.push(lastArgTupleValues);\n      }\n      var appArgsEncoded = [method.getSelector()];\n      for (var _i3 = 0; _i3 < basicArgTypes.length; _i3++) {\n        appArgsEncoded.push(basicArgTypes[_i3].encode(basicArgValues[_i3]));\n      }\n      var appCall = {\n        txn: makeApplicationCallTxnFromObject({\n          from: sender,\n          appIndex: appID,\n          appArgs: appArgsEncoded,\n          accounts: foreignAccounts,\n          foreignApps: foreignApps,\n          foreignAssets: foreignAssets,\n          boxes: boxReferences,\n          onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n          approvalProgram: approvalProgram,\n          clearProgram: clearProgram,\n          numGlobalInts: numGlobalInts,\n          numGlobalByteSlices: numGlobalByteSlices,\n          numLocalInts: numLocalInts,\n          numLocalByteSlices: numLocalByteSlices,\n          extraPages: extraPages,\n          lease: lease,\n          note: note,\n          rekeyTo: rekeyTo,\n          suggestedParams: suggestedParams\n        }),\n        signer: signer\n      };\n      (_this$transactions = this.transactions).push.apply(_this$transactions, txnArgs.concat([appCall]));\n      this.methodCalls.set(this.transactions.length - 1, method);\n    }\n    /**\n     * Finalize the transaction group and returned the finalized transactions.\n     *\n     * The composer's status will be at least BUILT after executing this method.\n     */\n  }, {\n    key: \"buildGroup\",\n    value: function buildGroup() {\n      if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n        if (this.transactions.length === 0) {\n          throw new Error('Cannot build a group with 0 transactions');\n        }\n        if (this.transactions.length > 1) {\n          assignGroupID(this.transactions.map(function (txnWithSigner) {\n            return txnWithSigner.txn;\n          }));\n        }\n        this.status = AtomicTransactionComposerStatus.BUILT;\n      }\n      return this.transactions;\n    }\n    /**\n     * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n     * this method will return cached versions of the signatures.\n     *\n     * The composer's status will be at least SIGNED after executing this method.\n     *\n     * An error will be thrown if signing any of the transactions fails.\n     *\n     * @returns A promise that resolves to an array of signed transactions.\n     */\n  }, {\n    key: \"gatherSignatures\",\n    value: function () {\n      var _gatherSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var txnsWithSigners, txnGroup, indexesPerSigner, i, signer, orderedSigners, batchedSigs, signedTxns, signerIndex, indexes, sigs, _i4, txIDs;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.status >= AtomicTransactionComposerStatus.SIGNED)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", this.signedTxns);\n            case 2:\n              // retrieve built transactions and verify status is BUILT\n              txnsWithSigners = this.buildGroup();\n              txnGroup = txnsWithSigners.map(function (txnWithSigner) {\n                return txnWithSigner.txn;\n              });\n              indexesPerSigner = new Map();\n              for (i = 0; i < txnsWithSigners.length; i++) {\n                signer = txnsWithSigners[i].signer;\n                if (!indexesPerSigner.has(signer)) {\n                  indexesPerSigner.set(signer, []);\n                }\n                indexesPerSigner.get(signer).push(i);\n              }\n              orderedSigners = Array.from(indexesPerSigner);\n              _context.next = 9;\n              return Promise.all(orderedSigners.map(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                  signer = _ref4[0],\n                  indexes = _ref4[1];\n                return signer(txnGroup, indexes);\n              }));\n            case 9:\n              batchedSigs = _context.sent;\n              signedTxns = txnsWithSigners.map(function () {\n                return null;\n              });\n              for (signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {\n                indexes = orderedSigners[signerIndex][1];\n                sigs = batchedSigs[signerIndex];\n                for (_i4 = 0; _i4 < indexes.length; _i4++) {\n                  signedTxns[indexes[_i4]] = sigs[_i4];\n                }\n              }\n              if (signedTxns.every(function (sig) {\n                return sig != null;\n              })) {\n                _context.next = 14;\n                break;\n              }\n              throw new Error(\"Missing signatures. Got \".concat(signedTxns));\n            case 14:\n              txIDs = signedTxns.map(function (stxn, index) {\n                try {\n                  return decodeSignedTransaction(stxn).txn.txID();\n                } catch (err) {\n                  throw new Error(\"Cannot decode signed transaction at index \".concat(index, \". \").concat(err));\n                }\n              });\n              this.signedTxns = signedTxns;\n              this.txIDs = txIDs;\n              this.status = AtomicTransactionComposerStatus.SIGNED;\n              return _context.abrupt(\"return\", signedTxns);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function gatherSignatures() {\n        return _gatherSignatures.apply(this, arguments);\n      }\n      return gatherSignatures;\n    }()\n    /**\n     * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n     * error will be thrown if submission fails.\n     *\n     * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n     * successful, this composer's status will update to SUBMITTED.\n     *\n     * Note: a group can only be submitted again if it fails.\n     *\n     * @param client - An Algodv2 client\n     *\n     * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n     */\n  }, {\n    key: \"submit\",\n    value: function () {\n      var _submit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(client) {\n        var stxns;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(this.status > AtomicTransactionComposerStatus.SUBMITTED)) {\n                _context2.next = 2;\n                break;\n              }\n              throw new Error('Transaction group cannot be resubmitted');\n            case 2:\n              _context2.next = 4;\n              return this.gatherSignatures();\n            case 4:\n              stxns = _context2.sent;\n              _context2.next = 7;\n              return client.sendRawTransaction(stxns).do();\n            case 7:\n              this.status = AtomicTransactionComposerStatus.SUBMITTED;\n              return _context2.abrupt(\"return\", this.txIDs);\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function submit(_x) {\n        return _submit.apply(this, arguments);\n      }\n      return submit;\n    }()\n    /**\n     * Simulates the transaction group in the network.\n     *\n     * The composer will try to sign any transactions in the group, then simulate\n     * the results.\n     * Simulating the group will not change the composer's status.\n     *\n     * @param client - An Algodv2 client\n     * @param request - SimulateRequest with options in simulation.\n     *   If provided, the request's transaction group will be overrwritten by the composer's group,\n     *   only simulation related options will be used.\n     *\n     * @returns A promise that, upon success, resolves to an object containing an\n     *   array of results containing one element for each method call transaction\n     *   in this group (ABIResult[]) and the SimulateResponse object.\n     */\n  }, {\n    key: \"simulate\",\n    value: function () {\n      var _simulate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(client, request) {\n        var stxns, txnObjects, currentRequest, simulateResponse, methodResults, _iterator, _step, _step$value, txnIndex, method, txID, pendingInfo, methodResult;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(this.status > AtomicTransactionComposerStatus.SUBMITTED)) {\n                _context3.next = 2;\n                break;\n              }\n              throw new Error('Simulated Transaction group has already been submitted to the network');\n            case 2:\n              _context3.next = 4;\n              return this.gatherSignatures();\n            case 4:\n              stxns = _context3.sent;\n              txnObjects = stxns.map(function (stxn) {\n                return encoding.decode(stxn);\n              });\n              currentRequest = request == null ? new SimulateRequest({\n                txnGroups: []\n              }) : request;\n              currentRequest.txnGroups = [new SimulateRequestTransactionGroup({\n                txns: txnObjects\n              })];\n              _context3.next = 10;\n              return client.simulateTransactions(currentRequest).do();\n            case 10:\n              simulateResponse = _context3.sent;\n              // Parse method response\n              methodResults = [];\n              _iterator = _createForOfIteratorHelper(this.methodCalls);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _step$value = _slicedToArray(_step.value, 2), txnIndex = _step$value[0], method = _step$value[1];\n                  txID = this.txIDs[txnIndex];\n                  pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n                  methodResult = {\n                    txID: txID,\n                    rawReturnValue: new Uint8Array(),\n                    method: method\n                  };\n                  methodResults.push(AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo.get_obj_for_encoding()));\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context3.abrupt(\"return\", {\n                methodResults: methodResults,\n                simulateResponse: simulateResponse\n              });\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function simulate(_x2, _x3) {\n        return _simulate.apply(this, arguments);\n      }\n      return simulate;\n    }()\n    /**\n     * Send the transaction group to the network and wait until it's committed to a block. An error\n     * will be thrown if submission or execution fails.\n     *\n     * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n     * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n     * If the execution is also successful, this composer's status will update to COMMITTED.\n     *\n     * Note: a group can only be submitted again if it fails.\n     *\n     * @param client - An Algodv2 client\n     * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n     *\n     * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n     *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n     *   one element for each method call transaction in this group.\n     */\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(client, waitRounds) {\n        var _this = this;\n        var txIDs, firstMethodCallIndex, indexToWaitFor, confirmedTxnInfo, confirmedRound, methodResults, _iterator2, _step2, _step2$value, txnIndex, method, txID, methodResult, pendingInfo;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(this.status === AtomicTransactionComposerStatus.COMMITTED)) {\n                _context4.next = 2;\n                break;\n              }\n              throw new Error('Transaction group has already been executed successfully');\n            case 2:\n              _context4.next = 4;\n              return this.submit(client);\n            case 4:\n              txIDs = _context4.sent;\n              this.status = AtomicTransactionComposerStatus.SUBMITTED;\n              firstMethodCallIndex = this.transactions.findIndex(function (_, index) {\n                return _this.methodCalls.has(index);\n              });\n              indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n              _context4.next = 10;\n              return waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);\n            case 10:\n              confirmedTxnInfo = _context4.sent;\n              this.status = AtomicTransactionComposerStatus.COMMITTED;\n              confirmedRound = confirmedTxnInfo['confirmed-round'];\n              methodResults = [];\n              _iterator2 = _createForOfIteratorHelper(this.methodCalls);\n              _context4.prev = 15;\n              _iterator2.s();\n            case 17:\n              if ((_step2 = _iterator2.n()).done) {\n                _context4.next = 39;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), txnIndex = _step2$value[0], method = _step2$value[1];\n              txID = txIDs[txnIndex];\n              methodResult = {\n                txID: txID,\n                rawReturnValue: new Uint8Array(),\n                method: method\n              };\n              _context4.prev = 21;\n              if (!(txnIndex === firstMethodCallIndex)) {\n                _context4.next = 26;\n                break;\n              }\n              _context4.t0 = confirmedTxnInfo;\n              _context4.next = 29;\n              break;\n            case 26:\n              _context4.next = 28;\n              return client.pendingTransactionInformation(txID).do();\n            case 28:\n              _context4.t0 = _context4.sent;\n            case 29:\n              pendingInfo = _context4.t0;\n              methodResult = AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);\n              _context4.next = 36;\n              break;\n            case 33:\n              _context4.prev = 33;\n              _context4.t1 = _context4[\"catch\"](21);\n              methodResult.decodeError = _context4.t1;\n            case 36:\n              methodResults.push(methodResult);\n            case 37:\n              _context4.next = 17;\n              break;\n            case 39:\n              _context4.next = 44;\n              break;\n            case 41:\n              _context4.prev = 41;\n              _context4.t2 = _context4[\"catch\"](15);\n              _iterator2.e(_context4.t2);\n            case 44:\n              _context4.prev = 44;\n              _iterator2.f();\n              return _context4.finish(44);\n            case 47:\n              return _context4.abrupt(\"return\", {\n                confirmedRound: confirmedRound,\n                txIDs: txIDs,\n                methodResults: methodResults\n              });\n            case 48:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[15, 41, 44, 47], [21, 33]]);\n      }));\n      function execute(_x4, _x5) {\n        return _execute.apply(this, arguments);\n      }\n      return execute;\n    }()\n    /**\n     * Parses a single ABI Method transaction log into a ABI result object.\n     *\n     * @param method\n     * @param methodResult\n     * @param pendingInfo\n     * @returns An ABIResult object\n     */\n  }], [{\n    key: \"parseMethodResponse\",\n    value: function parseMethodResponse(method, methodResult, pendingInfo) {\n      var returnedResult = methodResult;\n      try {\n        returnedResult.txInfo = pendingInfo;\n        if (method.returns.type !== 'void') {\n          var logs = pendingInfo.logs || [];\n          if (logs.length === 0) {\n            throw new Error('App call transaction did not log a return value');\n          }\n          var lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n          if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {\n            throw new Error('App call transaction did not log a return value');\n          }\n          returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n          returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);\n        }\n      } catch (err) {\n        returnedResult.decodeError = err;\n      }\n      return returnedResult;\n    }\n  }]);\n  return AtomicTransactionComposer;\n}();\n/** The maximum size of an atomic transaction group. */\nAtomicTransactionComposer.MAX_GROUP_SIZE = 16;","map":{"version":3,"names":["Buffer","ABIAddressType","abiCheckTransactionType","ABIReferenceType","ABITupleType","abiTypeIsReference","abiTypeIsTransaction","ABIUintType","SimulateRequest","SimulateRequestTransactionGroup","assignGroupID","makeApplicationCallTxnFromObject","isTransactionWithSigner","decodeSignedTransaction","Transaction","OnApplicationComplete","waitForConfirmation","encoding","RETURN_PREFIX","from","MAX_APP_ARGS","AtomicTransactionComposerStatus","populateForeignArray","valueToAdd","array","zeroValue","offset","i","length","push","AtomicTransactionComposer","_classCallCheck","status","BUILDING","transactions","methodCalls","Map","signedTxns","txIDs","_createClass","key","value","getStatus","count","clone","theClone","map","_ref","txn","signer","from_obj_for_encoding","_objectSpread","get_obj_for_encoding","grp","undefined","addTransaction","txnAndSigner","Error","MAX_GROUP_SIZE","concat","group","some","v","addMethodCall","_ref2","_this$transactions","appID","method","methodArgs","sender","suggestedParams","onComplete","approvalProgram","clearProgram","numGlobalInts","numGlobalByteSlices","numLocalInts","numLocalByteSlices","extraPages","appAccounts","appForeignApps","appForeignAssets","boxes","note","lease","rekeyTo","txnCount","UpdateApplicationOC","args","basicArgTypes","basicArgValues","txnArgs","refArgTypes","refArgValues","refArgIndexToBasicArgIndex","boxReferences","argType","type","argValue","set","resolvedRefIndexes","foreignAccounts","slice","foreignApps","foreignAssets","refType","refValue","resolved","account","addressType","address","decode","encode","application","uint64Type","refAppID","Number","MAX_SAFE_INTEGER","asset","refAssetID","basicArgIndex","get","lastArgTupleTypes","lastArgTupleValues","appArgsEncoded","getSelector","appCall","appIndex","appArgs","accounts","NoOpOC","apply","buildGroup","txnWithSigner","BUILT","_gatherSignatures","_asyncToGenerator","_regeneratorRuntime","mark","_callee","txnsWithSigners","txnGroup","indexesPerSigner","orderedSigners","batchedSigs","signerIndex","indexes","sigs","_i4","wrap","_callee$","_context","prev","next","SIGNED","abrupt","has","Array","Promise","all","_ref3","_ref4","_slicedToArray","sent","every","sig","stxn","index","txID","err","stop","gatherSignatures","arguments","_submit","_callee2","client","stxns","_callee2$","_context2","SUBMITTED","sendRawTransaction","do","submit","_x","_simulate","_callee3","request","txnObjects","currentRequest","simulateResponse","methodResults","_iterator","_step","_step$value","txnIndex","pendingInfo","methodResult","_callee3$","_context3","txnGroups","txns","simulateTransactions","_createForOfIteratorHelper","s","n","done","txnResults","txnResult","rawReturnValue","Uint8Array","parseMethodResponse","e","f","simulate","_x2","_x3","_execute","_callee4","waitRounds","_this","firstMethodCallIndex","indexToWaitFor","confirmedTxnInfo","confirmedRound","_iterator2","_step2","_step2$value","_callee4$","_context4","COMMITTED","findIndex","_","t0","pendingTransactionInformation","t1","decodeError","t2","finish","execute","_x4","_x5","returnedResult","txInfo","returns","logs","lastLog","byteLength","equals","returnValue"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/composer.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  ABIAddressType,\n  abiCheckTransactionType,\n  ABIMethod,\n  ABIReferenceType,\n  ABITupleType,\n  ABIType,\n  abiTypeIsReference,\n  abiTypeIsTransaction,\n  ABIUintType,\n  ABIValue,\n} from './abi';\nimport Algodv2 from './client/v2/algod/algod';\nimport {\n  SimulateResponse,\n  SimulateRequest,\n  SimulateRequestTransactionGroup,\n} from './client/v2/algod/models/types';\nimport { EncodedSignedTransaction } from './types';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport {\n  isTransactionWithSigner,\n  TransactionSigner,\n  TransactionWithSigner,\n} from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport {\n  BoxReference,\n  OnApplicationComplete,\n  SuggestedParams,\n} from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\nimport * as encoding from './encoding/encoding';\n\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\n\nexport type ABIArgument = ABIValue | TransactionWithSigner;\n\n/** Represents the output from a successful ABI method call. */\nexport interface ABIResult {\n  /** The TxID of the transaction that invoked the ABI method call. */\n  txID: string;\n  /**\n   * The raw bytes of the return value from the ABI method call. This will be empty if the method\n   * does not return a value (return type \"void\").\n   */\n  rawReturnValue: Uint8Array;\n  /**\n   * The method that was called for this result\n   */\n  method: ABIMethod;\n  /**\n   * The return value from the ABI method call. This will be undefined if the method does not return\n   * a value (return type \"void\"), or if the SDK was unable to decode the returned value.\n   */\n  returnValue?: ABIValue;\n  /** If the SDK was unable to decode a return value, the error will be here. */\n  decodeError?: Error;\n  /** The pending transaction information from the method transaction */\n  txInfo?: Record<string, any>;\n}\n\nexport enum AtomicTransactionComposerStatus {\n  /** The atomic group is still under construction. */\n  BUILDING,\n\n  /** The atomic group has been finalized, but not yet signed. */\n  BUILT,\n\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  SIGNED,\n\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  SUBMITTED,\n\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  COMMITTED,\n}\n\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray<Type>(\n  valueToAdd: Type,\n  array: Type[],\n  zeroValue?: Type\n): number {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n\n  const offset = zeroValue == null ? 0 : 1;\n\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  /** The maximum size of an atomic transaction group. */\n  static MAX_GROUP_SIZE: number = 16;\n\n  private status = AtomicTransactionComposerStatus.BUILDING;\n  private transactions: TransactionWithSigner[] = [];\n  private methodCalls: Map<number, ABIMethod> = new Map();\n  private signedTxns: Uint8Array[] = [];\n  private txIDs: string[] = [];\n\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus(): AtomicTransactionComposerStatus {\n    return this.status;\n  }\n\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count(): number {\n    return this.transactions.length;\n  }\n\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone(): AtomicTransactionComposer {\n    const theClone = new AtomicTransactionComposer();\n\n    theClone.transactions = this.transactions.map(({ txn, signer }) => ({\n      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n      txn: Transaction.from_obj_for_encoding({\n        ...txn.get_obj_for_encoding(),\n        // erase the group ID\n        grp: undefined,\n      }),\n      signer,\n    }));\n    theClone.methodCalls = new Map(this.methodCalls);\n\n    return theClone;\n  }\n\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner: TransactionWithSigner): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(\n        `Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n\n    this.transactions.push(txnAndSigner);\n  }\n\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer,\n  }: {\n    /** The ID of the smart contract to call. Set this to 0 to indicate an application creation call. */\n    appID: number;\n    /** The method to call on the smart contract */\n    method: ABIMethod;\n    /** The arguments to include in the method call. If omitted, no arguments will be passed to the method. */\n    methodArgs?: ABIArgument[];\n    /** The address of the sender of this application call */\n    sender: string;\n    /** Transactions params to use for this application call */\n    suggestedParams: SuggestedParams;\n    /** The OnComplete action to take for this application call. If omitted, OnApplicationComplete.NoOpOC will be used. */\n    onComplete?: OnApplicationComplete;\n    /** The approval program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    approvalProgram?: Uint8Array;\n    /** The clear program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    clearProgram?: Uint8Array;\n    /** The global integer schema size. Only set this if this is an application creation call. */\n    numGlobalInts?: number;\n    /** The global byte slice schema size. Only set this if this is an application creation call. */\n    numGlobalByteSlices?: number;\n    /** The local integer schema size. Only set this if this is an application creation call. */\n    numLocalInts?: number;\n    /** The local byte slice schema size. Only set this if this is an application creation call. */\n    numLocalByteSlices?: number;\n    /** The number of extra pages to allocate for the application's programs. Only set this if this is an application creation call. If omitted, defaults to 0. */\n    extraPages?: number;\n    /** Array of Address strings that represent external accounts supplied to this application. If accounts are provided here, the accounts specified in the method args will appear after these. */\n    appAccounts?: string[];\n    /** Array of App ID numbers that represent external apps supplied to this application. If apps are provided here, the apps specified in the method args will appear after these. */\n    appForeignApps?: number[];\n    /** Array of Asset ID numbers that represent external assets supplied to this application. If assets are provided here, the assets specified in the method args will appear after these. */\n    appForeignAssets?: number[];\n    /** The box references for this application call */\n    boxes?: BoxReference[];\n    /** The note value for this application call */\n    note?: Uint8Array;\n    /** The lease value for this application call */\n    lease?: Uint8Array;\n    /** If provided, the address that the sender will be rekeyed to at the conclusion of this application call */\n    rekeyTo?: string;\n    /** A transaction signer that can authorize this application call from sender */\n    signer: TransactionSigner;\n  }): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (\n      this.transactions.length + method.txnCount() >\n      AtomicTransactionComposer.MAX_GROUP_SIZE\n    ) {\n      throw new Error(\n        `Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (appID === 0) {\n      if (\n        approvalProgram == null ||\n        clearProgram == null ||\n        numGlobalInts == null ||\n        numGlobalByteSlices == null ||\n        numLocalInts == null ||\n        numLocalByteSlices == null\n      ) {\n        throw new Error(\n          'One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices'\n        );\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error(\n          'One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram'\n        );\n      }\n      if (\n        numGlobalInts != null ||\n        numGlobalByteSlices != null ||\n        numLocalInts != null ||\n        numLocalByteSlices != null ||\n        extraPages != null\n      ) {\n        throw new Error(\n          'One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n        );\n      }\n    } else if (\n      approvalProgram != null ||\n      clearProgram != null ||\n      numGlobalInts != null ||\n      numGlobalByteSlices != null ||\n      numLocalInts != null ||\n      numLocalByteSlices != null ||\n      extraPages != null\n    ) {\n      throw new Error(\n        'One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n      );\n    }\n\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(\n        `Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`\n      );\n    }\n\n    let basicArgTypes: ABIType[] = [];\n    let basicArgValues: ABIValue[] = [];\n    const txnArgs: TransactionWithSigner[] = [];\n    const refArgTypes: ABIReferenceType[] = [];\n    const refArgValues: ABIValue[] = [];\n    const refArgIndexToBasicArgIndex: Map<number, number> = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences: BoxReference[] = !boxes ? [] : boxes;\n\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n\n      if (abiTypeIsTransaction(argType)) {\n        if (\n          !isTransactionWithSigner(argValue) ||\n          !abiCheckTransactionType(argType, argValue.txn)\n        ) {\n          throw new Error(\n            `Expected ${argType} TransactionWithSigner for argument at index ${i}`\n          );\n        }\n        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(\n          `Expected non-transaction value for argument at index ${i}`\n        );\n      }\n\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(\n          refArgTypes.length,\n          basicArgTypes.length\n        );\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n\n    const resolvedRefIndexes: number[] = [];\n    const foreignAccounts: string[] =\n      appAccounts == null ? [] : appAccounts.slice();\n    const foreignApps: number[] =\n      appForeignApps == null ? [] : appForeignApps.slice();\n    const foreignAssets: number[] =\n      appForeignAssets == null ? [] : appForeignAssets.slice();\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n\n      switch (refType) {\n        case ABIReferenceType.account: {\n          const addressType = new ABIAddressType();\n          const address = addressType.decode(addressType.encode(refValue));\n          resolved = populateForeignArray(address, foreignAccounts, sender);\n          break;\n        }\n        case ABIReferenceType.application: {\n          const uint64Type = new ABIUintType(64);\n          const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAppID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for application value, got ${refAppID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n          break;\n        }\n        case ABIReferenceType.asset: {\n          const uint64Type = new ABIUintType(64);\n          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAssetID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for asset value, got ${refAssetID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n          break;\n        }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n\n      resolvedRefIndexes.push(resolved);\n    }\n\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n\n    const appArgsEncoded: Uint8Array[] = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete:\n          onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams,\n      }),\n      signer,\n    };\n\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup(): TransactionWithSigner[] {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(\n          this.transactions.map((txnWithSigner) => txnWithSigner.txn)\n        );\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures(): Promise<Uint8Array[]> {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);\n\n    const indexesPerSigner: Map<TransactionSigner, number[]> = new Map();\n\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const { signer } = txnsWithSigners[i];\n\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n\n      indexesPerSigner.get(signer).push(i);\n    }\n\n    const orderedSigners = Array.from(indexesPerSigner);\n\n    const batchedSigs = await Promise.all(\n      orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes))\n    );\n\n    const signedTxns: Array<Uint8Array | null> = txnsWithSigners.map(\n      () => null\n    );\n\n    for (\n      let signerIndex = 0;\n      signerIndex < orderedSigners.length;\n      signerIndex++\n    ) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n\n    if (!signedTxns.every((sig) => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(\n          `Cannot decode signed transaction at index ${index}. ${err}`\n        );\n      }\n    });\n\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n\n    return signedTxns;\n  }\n\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client: Algodv2): Promise<string[]> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n\n    const stxns = await this.gatherSignatures();\n\n    await client.sendRawTransaction(stxns).do();\n\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    return this.txIDs;\n  }\n\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   * @param request - SimulateRequest with options in simulation.\n   *   If provided, the request's transaction group will be overrwritten by the composer's group,\n   *   only simulation related options will be used.\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(\n    client: Algodv2,\n    request?: SimulateRequest\n  ): Promise<{\n    methodResults: ABIResult[];\n    simulateResponse: SimulateResponse;\n  }> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error(\n        'Simulated Transaction group has already been submitted to the network'\n      );\n    }\n\n    const stxns = await this.gatherSignatures();\n    const txnObjects: EncodedSignedTransaction[] = stxns.map(\n      (stxn) => encoding.decode(stxn) as EncodedSignedTransaction\n    );\n\n    const currentRequest: SimulateRequest =\n      request == null ? new SimulateRequest({ txnGroups: [] }) : request;\n\n    currentRequest.txnGroups = [\n      new SimulateRequestTransactionGroup({\n        txns: txnObjects,\n      }),\n    ];\n\n    const simulateResponse = await client\n      .simulateTransactions(currentRequest)\n      .do();\n\n    // Parse method response\n    const methodResults: ABIResult[] = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo =\n        simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n\n      const methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      methodResults.push(\n        AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo.get_obj_for_encoding()\n        )\n      );\n    }\n\n    return { methodResults, simulateResponse };\n  }\n\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(\n    client: Algodv2,\n    waitRounds: number\n  ): Promise<{\n    confirmedRound: number;\n    txIDs: string[];\n    methodResults: ABIResult[];\n  }> {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error(\n        'Transaction group has already been executed successfully'\n      );\n    }\n\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) =>\n      this.methodCalls.has(index)\n    );\n    const indexToWaitFor =\n      firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(\n      client,\n      txIDs[indexToWaitFor],\n      waitRounds\n    );\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n\n    const confirmedRound: number = confirmedTxnInfo['confirmed-round'];\n\n    const methodResults: ABIResult[] = [];\n\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n\n      let methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      try {\n        const pendingInfo =\n          txnIndex === firstMethodCallIndex\n            ? confirmedTxnInfo\n            : // eslint-disable-next-line no-await-in-loop\n              await client.pendingTransactionInformation(txID).do();\n\n        methodResult = AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo\n        );\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n\n      methodResults.push(methodResult);\n    }\n\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults,\n    };\n  }\n\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(\n    method: ABIMethod,\n    methodResult: ABIResult,\n    pendingInfo: Record<string, any>\n  ): ABIResult {\n    const returnedResult: ABIResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs: string[] = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n        if (\n          lastLog.byteLength < 4 ||\n          !lastLog.slice(0, 4).equals(RETURN_PREFIX)\n        ) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(\n          methodResult.rawReturnValue\n        );\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n\n    return returnedResult;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}