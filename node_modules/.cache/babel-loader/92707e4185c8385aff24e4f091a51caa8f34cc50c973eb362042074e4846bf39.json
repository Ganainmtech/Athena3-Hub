{"ast":null,"code":"/* eslint-disable no-bitwise */\nimport english from './wordlists/english';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as address from '../encoding/address';\nexport const FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = 'failed to decode mnemonic';\nexport const NOT_IN_WORDS_LIST_ERROR_MSG = 'the mnemonic contains a word that is not in the wordlist';\n// https://stackoverflow.com/a/51452614\nfunction toUint11Array(buffer8) {\n  const buffer11 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(octet) {\n    acc |= octet << accBits;\n    accBits += 8;\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n}\nfunction applyWords(nums) {\n  return nums.map(n => english[n]);\n}\nfunction computeChecksum(seed) {\n  const hashBuffer = nacl.genericHash(seed);\n  const uint11Hash = toUint11Array(hashBuffer);\n  const words = applyWords(uint11Hash);\n  return words[0];\n}\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed - 32 bytes long seed\n * @returns 25 words mnemonic\n */\nexport function mnemonicFromSeed(seed) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(`Seed length must be ${nacl.SEED_BTYES_LENGTH}`);\n  }\n  const uint11Array = toUint11Array(seed);\n  const words = applyWords(uint11Array);\n  const checksumWord = computeChecksum(seed);\n  return `${words.join(' ')} ${checksumWord}`;\n}\n// from Uint11Array\n// https://stackoverflow.com/a/51452614\nfunction toUint8Array(buffer11) {\n  const buffer8 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(ui11) {\n    acc |= ui11 << accBits;\n    accBits += 11;\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic - 25 words mnemonic\n * @returns 32 bytes long seed\n */\nexport function seedFromMnemonic(mnemonic) {\n  const words = mnemonic.split(' ');\n  const key = words.slice(0, 24);\n  // Check that all words are in list\n  for (const w of key) {\n    if (english.indexOf(w) === -1) throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);\n  }\n  const checksum = words[words.length - 1];\n  const uint11Array = key.map(word => english.indexOf(word));\n  // Convert the key to uint8Array\n  let uint8Array = toUint8Array(uint11Array);\n  // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n  // check that we have 33 bytes long array as expected\n  if (uint8Array.length !== 33) throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n  // check that the last byte is actually 0x0\n  if (uint8Array[uint8Array.length - 1] !== 0x0) throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n  // chop it !\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1);\n  // compute checksum\n  const cs = computeChecksum(uint8Array);\n  // success!\n  if (cs === checksum) return uint8Array;\n  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n}\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn - 25 words Algorand mnemonic\n * @throws error if fails to decode the mnemonic\n */\nexport function mnemonicToSecretKey(mn) {\n  const seed = seedFromMnemonic(mn);\n  const keys = nacl.keyPairFromSeed(seed);\n  const encodedPk = address.encodeAddress(keys.publicKey);\n  return {\n    addr: encodedPk,\n    sk: keys.secretKey\n  };\n}\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk - Algorand secret key\n * @returns Secret key's associated mnemonic\n */\nexport function secretKeyToMnemonic(sk) {\n  // get the seed from the sk\n  const seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonicFromSeed(seed);\n}\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn - 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\nexport function mnemonicToMasterDerivationKey(mn) {\n  return seedFromMnemonic(mn);\n}\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk - Uint8Array\n * @returns string mnemonic\n */\nexport function masterDerivationKeyToMnemonic(mdk) {\n  return mnemonicFromSeed(mdk);\n}","map":{"version":3,"names":["english","nacl","address","FAIL_TO_DECODE_MNEMONIC_ERROR_MSG","NOT_IN_WORDS_LIST_ERROR_MSG","toUint11Array","buffer8","buffer11","acc","accBits","add","octet","push","flush","forEach","applyWords","nums","map","n","computeChecksum","seed","hashBuffer","genericHash","uint11Hash","words","mnemonicFromSeed","length","SEED_BTYES_LENGTH","RangeError","uint11Array","checksumWord","join","toUint8Array","ui11","Uint8Array","seedFromMnemonic","mnemonic","split","key","slice","w","indexOf","Error","checksum","word","uint8Array","cs","mnemonicToSecretKey","mn","keys","keyPairFromSeed","encodedPk","encodeAddress","publicKey","addr","sk","secretKey","secretKeyToMnemonic","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","mdk"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/node_modules/algosdk/src/mnemonic/mnemonic.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport english from './wordlists/english';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as address from '../encoding/address';\nimport Account from '../types/account';\n\nexport const FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = 'failed to decode mnemonic';\nexport const NOT_IN_WORDS_LIST_ERROR_MSG =\n  'the mnemonic contains a word that is not in the wordlist';\n\n// https://stackoverflow.com/a/51452614\nfunction toUint11Array(buffer8: Uint8Array | number[]) {\n  const buffer11 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(octet) {\n    acc |= octet << accBits;\n    accBits += 8;\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n}\n\nfunction applyWords(nums: number[]) {\n  return nums.map((n) => english[n]);\n}\n\nfunction computeChecksum(seed: Uint8Array) {\n  const hashBuffer = nacl.genericHash(seed);\n  const uint11Hash = toUint11Array(hashBuffer);\n  const words = applyWords(uint11Hash);\n\n  return words[0];\n}\n\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed - 32 bytes long seed\n * @returns 25 words mnemonic\n */\nexport function mnemonicFromSeed(seed: Uint8Array) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(`Seed length must be ${nacl.SEED_BTYES_LENGTH}`);\n  }\n\n  const uint11Array = toUint11Array(seed);\n  const words = applyWords(uint11Array);\n  const checksumWord = computeChecksum(seed);\n\n  return `${words.join(' ')} ${checksumWord}`;\n}\n\n// from Uint11Array\n// https://stackoverflow.com/a/51452614\nfunction toUint8Array(buffer11: number[]) {\n  const buffer8 = [];\n  let acc = 0;\n  let accBits = 0;\n  function add(ui11) {\n    acc |= ui11 << accBits;\n    accBits += 11;\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic - 25 words mnemonic\n * @returns 32 bytes long seed\n */\nexport function seedFromMnemonic(mnemonic: string) {\n  const words = mnemonic.split(' ');\n  const key = words.slice(0, 24);\n\n  // Check that all words are in list\n  for (const w of key) {\n    if (english.indexOf(w) === -1) throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);\n  }\n\n  const checksum = words[words.length - 1];\n  const uint11Array = key.map((word) => english.indexOf(word));\n\n  // Convert the key to uint8Array\n  let uint8Array = toUint8Array(uint11Array);\n\n  // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n\n  // check that we have 33 bytes long array as expected\n  if (uint8Array.length !== 33)\n    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n\n  // check that the last byte is actually 0x0\n  if (uint8Array[uint8Array.length - 1] !== 0x0)\n    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n\n  // chop it !\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1);\n\n  // compute checksum\n  const cs = computeChecksum(uint8Array);\n\n  // success!\n  if (cs === checksum) return uint8Array;\n\n  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);\n}\n\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn - 25 words Algorand mnemonic\n * @throws error if fails to decode the mnemonic\n */\nexport function mnemonicToSecretKey(mn: string): Account {\n  const seed = seedFromMnemonic(mn);\n  const keys = nacl.keyPairFromSeed(seed);\n  const encodedPk = address.encodeAddress(keys.publicKey);\n  return { addr: encodedPk, sk: keys.secretKey };\n}\n\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk - Algorand secret key\n * @returns Secret key's associated mnemonic\n */\nexport function secretKeyToMnemonic(sk: Uint8Array) {\n  // get the seed from the sk\n  const seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonicFromSeed(seed);\n}\n\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn - 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\nexport function mnemonicToMasterDerivationKey(mn: string) {\n  return seedFromMnemonic(mn);\n}\n\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk - Uint8Array\n * @returns string mnemonic\n */\nexport function masterDerivationKeyToMnemonic(mdk: Uint8Array) {\n  return mnemonicFromSeed(mdk);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}