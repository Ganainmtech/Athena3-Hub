{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { ABIAddressType, abiCheckTransactionType, ABIReferenceType, ABITupleType, abiTypeIsReference, abiTypeIsTransaction, ABIUintType } from './abi';\nimport { SimulateRequest, SimulateRequestTransactionGroup } from './client/v2/algod/models/types';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport { isTransactionWithSigner } from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport { OnApplicationComplete } from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\nimport * as encoding from './encoding/encoding';\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\nexport var AtomicTransactionComposerStatus;\n(function (AtomicTransactionComposerStatus) {\n  /** The atomic group is still under construction. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILDING\"] = 0] = \"BUILDING\";\n  /** The atomic group has been finalized, but not yet signed. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILT\"] = 1] = \"BUILT\";\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SIGNED\"] = 2] = \"SIGNED\";\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SUBMITTED\"] = 3] = \"SUBMITTED\";\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"COMMITTED\"] = 4] = \"COMMITTED\";\n})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray(valueToAdd, array, zeroValue) {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n  const offset = zeroValue == null ? 0 : 1;\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  constructor() {\n    this.status = AtomicTransactionComposerStatus.BUILDING;\n    this.transactions = [];\n    this.methodCalls = new Map();\n    this.signedTxns = [];\n    this.txIDs = [];\n  }\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus() {\n    return this.status;\n  }\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count() {\n    return this.transactions.length;\n  }\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone() {\n    const theClone = new AtomicTransactionComposer();\n    theClone.transactions = this.transactions.map(({\n      txn,\n      signer\n    }) => ({\n      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n      txn: Transaction.from_obj_for_encoding({\n        ...txn.get_obj_for_encoding(),\n        // erase the group ID\n        grp: undefined\n      }),\n      signer\n    }));\n    theClone.methodCalls = new Map(this.methodCalls);\n    return theClone;\n  }\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some(v => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n    this.transactions.push(txnAndSigner);\n  }\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer\n  }) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (appID === 0) {\n      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {\n        throw new Error('One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices');\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error('One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram');\n      }\n      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n        throw new Error('One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n      }\n    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n      throw new Error('One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n    }\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);\n    }\n    let basicArgTypes = [];\n    let basicArgValues = [];\n    const txnArgs = [];\n    const refArgTypes = [];\n    const refArgValues = [];\n    const refArgIndexToBasicArgIndex = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences = !boxes ? [] : boxes;\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n      if (abiTypeIsTransaction(argType)) {\n        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {\n          throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i}`);\n        }\n        if (argValue.txn.group && argValue.txn.group.some(v => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(`Expected non-transaction value for argument at index ${i}`);\n      }\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n    const resolvedRefIndexes = [];\n    const foreignAccounts = appAccounts == null ? [] : appAccounts.slice();\n    const foreignApps = appForeignApps == null ? [] : appForeignApps.slice();\n    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.slice();\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n      switch (refType) {\n        case ABIReferenceType.account:\n          {\n            const addressType = new ABIAddressType();\n            const address = addressType.decode(addressType.encode(refValue));\n            resolved = populateForeignArray(address, foreignAccounts, sender);\n            break;\n          }\n        case ABIReferenceType.application:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAppID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for application value, got ${refAppID}`);\n            }\n            resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n            break;\n          }\n        case ABIReferenceType.asset:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAssetID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);\n            }\n            resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n            break;\n          }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n      resolvedRefIndexes.push(resolved);\n    }\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n    const appArgsEncoded = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams\n      }),\n      signer\n    };\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup() {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(this.transactions.map(txnWithSigner => txnWithSigner.txn));\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures() {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map(txnWithSigner => txnWithSigner.txn);\n    const indexesPerSigner = new Map();\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const {\n        signer\n      } = txnsWithSigners[i];\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n      indexesPerSigner.get(signer).push(i);\n    }\n    const orderedSigners = Array.from(indexesPerSigner);\n    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));\n    const signedTxns = txnsWithSigners.map(() => null);\n    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n    if (!signedTxns.every(sig => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);\n      }\n    });\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n    return signedTxns;\n  }\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n    const stxns = await this.gatherSignatures();\n    await client.sendRawTransaction(stxns).do();\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    return this.txIDs;\n  }\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   * @param request - SimulateRequest with options in simulation.\n   *   If provided, the request's transaction group will be overrwritten by the composer's group,\n   *   only simulation related options will be used.\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(client, request) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Simulated Transaction group has already been submitted to the network');\n    }\n    const stxns = await this.gatherSignatures();\n    const txnObjects = stxns.map(stxn => encoding.decode(stxn));\n    const currentRequest = request == null ? new SimulateRequest({\n      txnGroups: []\n    }) : request;\n    currentRequest.txnGroups = [new SimulateRequestTransactionGroup({\n      txns: txnObjects\n    })];\n    const simulateResponse = await client.simulateTransactions(currentRequest).do();\n    // Parse method response\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n      const methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      methodResults.push(AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo.get_obj_for_encoding()));\n    }\n    return {\n      methodResults,\n      simulateResponse\n    };\n  }\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(client, waitRounds) {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error('Transaction group has already been executed successfully');\n    }\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));\n    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n    const confirmedRound = confirmedTxnInfo['confirmed-round'];\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n      let methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      try {\n        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo :\n        // eslint-disable-next-line no-await-in-loop\n        await client.pendingTransactionInformation(txID).do();\n        methodResult = AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n      methodResults.push(methodResult);\n    }\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults\n    };\n  }\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(method, methodResult, pendingInfo) {\n    const returnedResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error('App call transaction did not log a return value');\n        }\n        const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n        if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {\n          throw new Error('App call transaction did not log a return value');\n        }\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n    return returnedResult;\n  }\n}\n/** The maximum size of an atomic transaction group. */\nAtomicTransactionComposer.MAX_GROUP_SIZE = 16;","map":{"version":3,"names":["Buffer","ABIAddressType","abiCheckTransactionType","ABIReferenceType","ABITupleType","abiTypeIsReference","abiTypeIsTransaction","ABIUintType","SimulateRequest","SimulateRequestTransactionGroup","assignGroupID","makeApplicationCallTxnFromObject","isTransactionWithSigner","decodeSignedTransaction","Transaction","OnApplicationComplete","waitForConfirmation","encoding","RETURN_PREFIX","from","MAX_APP_ARGS","AtomicTransactionComposerStatus","populateForeignArray","valueToAdd","array","zeroValue","offset","i","length","push","AtomicTransactionComposer","constructor","status","BUILDING","transactions","methodCalls","Map","signedTxns","txIDs","getStatus","count","clone","theClone","map","txn","signer","from_obj_for_encoding","get_obj_for_encoding","grp","undefined","addTransaction","txnAndSigner","Error","MAX_GROUP_SIZE","group","some","v","addMethodCall","appID","method","methodArgs","sender","suggestedParams","onComplete","approvalProgram","clearProgram","numGlobalInts","numGlobalByteSlices","numLocalInts","numLocalByteSlices","extraPages","appAccounts","appForeignApps","appForeignAssets","boxes","note","lease","rekeyTo","txnCount","UpdateApplicationOC","args","basicArgTypes","basicArgValues","txnArgs","refArgTypes","refArgValues","refArgIndexToBasicArgIndex","boxReferences","argType","type","argValue","set","resolvedRefIndexes","foreignAccounts","slice","foreignApps","foreignAssets","refType","refValue","resolved","account","addressType","address","decode","encode","application","uint64Type","refAppID","Number","MAX_SAFE_INTEGER","asset","refAssetID","basicArgIndex","get","lastArgTupleTypes","lastArgTupleValues","appArgsEncoded","getSelector","appCall","appIndex","appArgs","accounts","NoOpOC","buildGroup","txnWithSigner","BUILT","gatherSignatures","SIGNED","txnsWithSigners","txnGroup","indexesPerSigner","has","orderedSigners","Array","batchedSigs","Promise","all","indexes","signerIndex","sigs","every","sig","stxn","index","txID","err","submit","client","SUBMITTED","stxns","sendRawTransaction","do","simulate","request","txnObjects","currentRequest","txnGroups","txns","simulateResponse","simulateTransactions","methodResults","txnIndex","pendingInfo","txnResults","txnResult","methodResult","rawReturnValue","Uint8Array","parseMethodResponse","execute","waitRounds","COMMITTED","firstMethodCallIndex","findIndex","_","indexToWaitFor","confirmedTxnInfo","confirmedRound","pendingTransactionInformation","decodeError","returnedResult","txInfo","returns","logs","lastLog","byteLength","equals","returnValue"],"sources":["/Users/wanjinwoo/Desktop/Study/web3/Algorand/Athena3-Hub/Athena3-Hub-athena-frontend/node_modules/algosdk/src/composer.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  ABIAddressType,\n  abiCheckTransactionType,\n  ABIMethod,\n  ABIReferenceType,\n  ABITupleType,\n  ABIType,\n  abiTypeIsReference,\n  abiTypeIsTransaction,\n  ABIUintType,\n  ABIValue,\n} from './abi';\nimport Algodv2 from './client/v2/algod/algod';\nimport {\n  SimulateResponse,\n  SimulateRequest,\n  SimulateRequestTransactionGroup,\n} from './client/v2/algod/models/types';\nimport { EncodedSignedTransaction } from './types';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport {\n  isTransactionWithSigner,\n  TransactionSigner,\n  TransactionWithSigner,\n} from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport {\n  BoxReference,\n  OnApplicationComplete,\n  SuggestedParams,\n} from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\nimport * as encoding from './encoding/encoding';\n\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\n\nexport type ABIArgument = ABIValue | TransactionWithSigner;\n\n/** Represents the output from a successful ABI method call. */\nexport interface ABIResult {\n  /** The TxID of the transaction that invoked the ABI method call. */\n  txID: string;\n  /**\n   * The raw bytes of the return value from the ABI method call. This will be empty if the method\n   * does not return a value (return type \"void\").\n   */\n  rawReturnValue: Uint8Array;\n  /**\n   * The method that was called for this result\n   */\n  method: ABIMethod;\n  /**\n   * The return value from the ABI method call. This will be undefined if the method does not return\n   * a value (return type \"void\"), or if the SDK was unable to decode the returned value.\n   */\n  returnValue?: ABIValue;\n  /** If the SDK was unable to decode a return value, the error will be here. */\n  decodeError?: Error;\n  /** The pending transaction information from the method transaction */\n  txInfo?: Record<string, any>;\n}\n\nexport enum AtomicTransactionComposerStatus {\n  /** The atomic group is still under construction. */\n  BUILDING,\n\n  /** The atomic group has been finalized, but not yet signed. */\n  BUILT,\n\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  SIGNED,\n\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  SUBMITTED,\n\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  COMMITTED,\n}\n\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray<Type>(\n  valueToAdd: Type,\n  array: Type[],\n  zeroValue?: Type\n): number {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n\n  const offset = zeroValue == null ? 0 : 1;\n\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  /** The maximum size of an atomic transaction group. */\n  static MAX_GROUP_SIZE: number = 16;\n\n  private status = AtomicTransactionComposerStatus.BUILDING;\n  private transactions: TransactionWithSigner[] = [];\n  private methodCalls: Map<number, ABIMethod> = new Map();\n  private signedTxns: Uint8Array[] = [];\n  private txIDs: string[] = [];\n\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus(): AtomicTransactionComposerStatus {\n    return this.status;\n  }\n\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count(): number {\n    return this.transactions.length;\n  }\n\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone(): AtomicTransactionComposer {\n    const theClone = new AtomicTransactionComposer();\n\n    theClone.transactions = this.transactions.map(({ txn, signer }) => ({\n      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n      txn: Transaction.from_obj_for_encoding({\n        ...txn.get_obj_for_encoding(),\n        // erase the group ID\n        grp: undefined,\n      }),\n      signer,\n    }));\n    theClone.methodCalls = new Map(this.methodCalls);\n\n    return theClone;\n  }\n\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner: TransactionWithSigner): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(\n        `Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n\n    this.transactions.push(txnAndSigner);\n  }\n\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer,\n  }: {\n    /** The ID of the smart contract to call. Set this to 0 to indicate an application creation call. */\n    appID: number;\n    /** The method to call on the smart contract */\n    method: ABIMethod;\n    /** The arguments to include in the method call. If omitted, no arguments will be passed to the method. */\n    methodArgs?: ABIArgument[];\n    /** The address of the sender of this application call */\n    sender: string;\n    /** Transactions params to use for this application call */\n    suggestedParams: SuggestedParams;\n    /** The OnComplete action to take for this application call. If omitted, OnApplicationComplete.NoOpOC will be used. */\n    onComplete?: OnApplicationComplete;\n    /** The approval program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    approvalProgram?: Uint8Array;\n    /** The clear program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    clearProgram?: Uint8Array;\n    /** The global integer schema size. Only set this if this is an application creation call. */\n    numGlobalInts?: number;\n    /** The global byte slice schema size. Only set this if this is an application creation call. */\n    numGlobalByteSlices?: number;\n    /** The local integer schema size. Only set this if this is an application creation call. */\n    numLocalInts?: number;\n    /** The local byte slice schema size. Only set this if this is an application creation call. */\n    numLocalByteSlices?: number;\n    /** The number of extra pages to allocate for the application's programs. Only set this if this is an application creation call. If omitted, defaults to 0. */\n    extraPages?: number;\n    /** Array of Address strings that represent external accounts supplied to this application. If accounts are provided here, the accounts specified in the method args will appear after these. */\n    appAccounts?: string[];\n    /** Array of App ID numbers that represent external apps supplied to this application. If apps are provided here, the apps specified in the method args will appear after these. */\n    appForeignApps?: number[];\n    /** Array of Asset ID numbers that represent external assets supplied to this application. If assets are provided here, the assets specified in the method args will appear after these. */\n    appForeignAssets?: number[];\n    /** The box references for this application call */\n    boxes?: BoxReference[];\n    /** The note value for this application call */\n    note?: Uint8Array;\n    /** The lease value for this application call */\n    lease?: Uint8Array;\n    /** If provided, the address that the sender will be rekeyed to at the conclusion of this application call */\n    rekeyTo?: string;\n    /** A transaction signer that can authorize this application call from sender */\n    signer: TransactionSigner;\n  }): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (\n      this.transactions.length + method.txnCount() >\n      AtomicTransactionComposer.MAX_GROUP_SIZE\n    ) {\n      throw new Error(\n        `Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (appID === 0) {\n      if (\n        approvalProgram == null ||\n        clearProgram == null ||\n        numGlobalInts == null ||\n        numGlobalByteSlices == null ||\n        numLocalInts == null ||\n        numLocalByteSlices == null\n      ) {\n        throw new Error(\n          'One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices'\n        );\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error(\n          'One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram'\n        );\n      }\n      if (\n        numGlobalInts != null ||\n        numGlobalByteSlices != null ||\n        numLocalInts != null ||\n        numLocalByteSlices != null ||\n        extraPages != null\n      ) {\n        throw new Error(\n          'One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n        );\n      }\n    } else if (\n      approvalProgram != null ||\n      clearProgram != null ||\n      numGlobalInts != null ||\n      numGlobalByteSlices != null ||\n      numLocalInts != null ||\n      numLocalByteSlices != null ||\n      extraPages != null\n    ) {\n      throw new Error(\n        'One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n      );\n    }\n\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(\n        `Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`\n      );\n    }\n\n    let basicArgTypes: ABIType[] = [];\n    let basicArgValues: ABIValue[] = [];\n    const txnArgs: TransactionWithSigner[] = [];\n    const refArgTypes: ABIReferenceType[] = [];\n    const refArgValues: ABIValue[] = [];\n    const refArgIndexToBasicArgIndex: Map<number, number> = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences: BoxReference[] = !boxes ? [] : boxes;\n\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n\n      if (abiTypeIsTransaction(argType)) {\n        if (\n          !isTransactionWithSigner(argValue) ||\n          !abiCheckTransactionType(argType, argValue.txn)\n        ) {\n          throw new Error(\n            `Expected ${argType} TransactionWithSigner for argument at index ${i}`\n          );\n        }\n        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(\n          `Expected non-transaction value for argument at index ${i}`\n        );\n      }\n\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(\n          refArgTypes.length,\n          basicArgTypes.length\n        );\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n\n    const resolvedRefIndexes: number[] = [];\n    const foreignAccounts: string[] =\n      appAccounts == null ? [] : appAccounts.slice();\n    const foreignApps: number[] =\n      appForeignApps == null ? [] : appForeignApps.slice();\n    const foreignAssets: number[] =\n      appForeignAssets == null ? [] : appForeignAssets.slice();\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n\n      switch (refType) {\n        case ABIReferenceType.account: {\n          const addressType = new ABIAddressType();\n          const address = addressType.decode(addressType.encode(refValue));\n          resolved = populateForeignArray(address, foreignAccounts, sender);\n          break;\n        }\n        case ABIReferenceType.application: {\n          const uint64Type = new ABIUintType(64);\n          const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAppID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for application value, got ${refAppID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n          break;\n        }\n        case ABIReferenceType.asset: {\n          const uint64Type = new ABIUintType(64);\n          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAssetID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for asset value, got ${refAssetID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n          break;\n        }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n\n      resolvedRefIndexes.push(resolved);\n    }\n\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n\n    const appArgsEncoded: Uint8Array[] = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete:\n          onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams,\n      }),\n      signer,\n    };\n\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup(): TransactionWithSigner[] {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(\n          this.transactions.map((txnWithSigner) => txnWithSigner.txn)\n        );\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures(): Promise<Uint8Array[]> {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);\n\n    const indexesPerSigner: Map<TransactionSigner, number[]> = new Map();\n\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const { signer } = txnsWithSigners[i];\n\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n\n      indexesPerSigner.get(signer).push(i);\n    }\n\n    const orderedSigners = Array.from(indexesPerSigner);\n\n    const batchedSigs = await Promise.all(\n      orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes))\n    );\n\n    const signedTxns: Array<Uint8Array | null> = txnsWithSigners.map(\n      () => null\n    );\n\n    for (\n      let signerIndex = 0;\n      signerIndex < orderedSigners.length;\n      signerIndex++\n    ) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n\n    if (!signedTxns.every((sig) => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(\n          `Cannot decode signed transaction at index ${index}. ${err}`\n        );\n      }\n    });\n\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n\n    return signedTxns;\n  }\n\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client: Algodv2): Promise<string[]> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n\n    const stxns = await this.gatherSignatures();\n\n    await client.sendRawTransaction(stxns).do();\n\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    return this.txIDs;\n  }\n\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   * @param request - SimulateRequest with options in simulation.\n   *   If provided, the request's transaction group will be overrwritten by the composer's group,\n   *   only simulation related options will be used.\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(\n    client: Algodv2,\n    request?: SimulateRequest\n  ): Promise<{\n    methodResults: ABIResult[];\n    simulateResponse: SimulateResponse;\n  }> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error(\n        'Simulated Transaction group has already been submitted to the network'\n      );\n    }\n\n    const stxns = await this.gatherSignatures();\n    const txnObjects: EncodedSignedTransaction[] = stxns.map(\n      (stxn) => encoding.decode(stxn) as EncodedSignedTransaction\n    );\n\n    const currentRequest: SimulateRequest =\n      request == null ? new SimulateRequest({ txnGroups: [] }) : request;\n\n    currentRequest.txnGroups = [\n      new SimulateRequestTransactionGroup({\n        txns: txnObjects,\n      }),\n    ];\n\n    const simulateResponse = await client\n      .simulateTransactions(currentRequest)\n      .do();\n\n    // Parse method response\n    const methodResults: ABIResult[] = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo =\n        simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n\n      const methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      methodResults.push(\n        AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo.get_obj_for_encoding()\n        )\n      );\n    }\n\n    return { methodResults, simulateResponse };\n  }\n\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(\n    client: Algodv2,\n    waitRounds: number\n  ): Promise<{\n    confirmedRound: number;\n    txIDs: string[];\n    methodResults: ABIResult[];\n  }> {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error(\n        'Transaction group has already been executed successfully'\n      );\n    }\n\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) =>\n      this.methodCalls.has(index)\n    );\n    const indexToWaitFor =\n      firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(\n      client,\n      txIDs[indexToWaitFor],\n      waitRounds\n    );\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n\n    const confirmedRound: number = confirmedTxnInfo['confirmed-round'];\n\n    const methodResults: ABIResult[] = [];\n\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n\n      let methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      try {\n        const pendingInfo =\n          txnIndex === firstMethodCallIndex\n            ? confirmedTxnInfo\n            : // eslint-disable-next-line no-await-in-loop\n              await client.pendingTransactionInformation(txID).do();\n\n        methodResult = AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo\n        );\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n\n      methodResults.push(methodResult);\n    }\n\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults,\n    };\n  }\n\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(\n    method: ABIMethod,\n    methodResult: ABIResult,\n    pendingInfo: Record<string, any>\n  ): ABIResult {\n    const returnedResult: ABIResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs: string[] = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n        if (\n          lastLog.byteLength < 4 ||\n          !lastLog.slice(0, 4).equals(RETURN_PREFIX)\n        ) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(\n          methodResult.rawReturnValue\n        );\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n\n    return returnedResult;\n  }\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,SACEC,cAAc,EACdC,uBAAuB,EAEvBC,gBAAgB,EAChBC,YAAY,EAEZC,kBAAkB,EAClBC,oBAAoB,EACpBC,WAAW,QAEN,OAAO;AAEd,SAEEC,eAAe,EACfC,+BAA+B,QAC1B,gCAAgC;AAEvC,SAASC,aAAa,QAAQ,SAAS;AACvC,SAASC,gCAAgC,QAAQ,WAAW;AAC5D,SACEC,uBAAuB,QAGlB,UAAU;AACjB,SAASC,uBAAuB,EAAEC,WAAW,QAAQ,eAAe;AACpE,SAEEC,qBAAqB,QAEhB,2BAA2B;AAClC,SAASC,mBAAmB,QAAQ,QAAQ;AAC5C,OAAO,KAAKC,QAAQ,MAAM,qBAAqB;AAE/C;AACA,MAAMC,aAAa,GAAGlB,MAAM,CAACmB,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AAErD;AACA,MAAMC,YAAY,GAAG,EAAE;AA4BvB,WAAYC,+BAeX;AAfD,WAAYA,+BAA+B;EACzC;EACAA,+BAAA,CAAAA,+BAAA,8BAAQ;EAER;EACAA,+BAAA,CAAAA,+BAAA,wBAAK;EAEL;EACAA,+BAAA,CAAAA,+BAAA,0BAAM;EAEN;EACAA,+BAAA,CAAAA,+BAAA,gCAAS;EAET;EACAA,+BAAA,CAAAA,+BAAA,gCAAS;AACX,CAAC,EAfWA,+BAA+B,KAA/BA,+BAA+B;AAiB3C;;;;;;;;;;;;;AAaA,SAASC,oBAAoBA,CAC3BC,UAAgB,EAChBC,KAAa,EACbC,SAAgB;EAEhB,IAAIA,SAAS,IAAI,IAAI,IAAIF,UAAU,KAAKE,SAAS,EAAE;IACjD,OAAO,CAAC;;EAGV,MAAMC,MAAM,GAAGD,SAAS,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC;EAExC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIJ,UAAU,KAAKC,KAAK,CAACG,CAAC,CAAC,EAAE;MAC3B,OAAOA,CAAC,GAAGD,MAAM;;;EAIrBF,KAAK,CAACK,IAAI,CAACN,UAAU,CAAC;EACtB,OAAOC,KAAK,CAACI,MAAM,GAAG,CAAC,GAAGF,MAAM;AAClC;AAEA;AACA,OAAM,MAAOI,yBAAyB;EAAtCC,YAAA;IAIU,KAAAC,MAAM,GAAGX,+BAA+B,CAACY,QAAQ;IACjD,KAAAC,YAAY,GAA4B,EAAE;IAC1C,KAAAC,WAAW,GAA2B,IAAIC,GAAG,EAAE;IAC/C,KAAAC,UAAU,GAAiB,EAAE;IAC7B,KAAAC,KAAK,GAAa,EAAE;EAuqB9B;EArqBE;;;EAGAC,SAASA,CAAA;IACP,OAAO,IAAI,CAACP,MAAM;EACpB;EAEA;;;EAGAQ,KAAKA,CAAA;IACH,OAAO,IAAI,CAACN,YAAY,CAACN,MAAM;EACjC;EAEA;;;;EAIAa,KAAKA,CAAA;IACH,MAAMC,QAAQ,GAAG,IAAIZ,yBAAyB,EAAE;IAEhDY,QAAQ,CAACR,YAAY,GAAG,IAAI,CAACA,YAAY,CAACS,GAAG,CAAC,CAAC;MAAEC,GAAG;MAAEC;IAAM,CAAE,MAAM;MAClE;MACAD,GAAG,EAAE9B,WAAW,CAACgC,qBAAqB,CAAC;QACrC,GAAGF,GAAG,CAACG,oBAAoB,EAAE;QAC7B;QACAC,GAAG,EAAEC;OACN,CAAC;MACFJ;KACD,CAAC,CAAC;IACHH,QAAQ,CAACP,WAAW,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACD,WAAW,CAAC;IAEhD,OAAOO,QAAQ;EACjB;EAEA;;;;;;EAMAQ,cAAcA,CAACC,YAAmC;IAChD,IAAI,IAAI,CAACnB,MAAM,KAAKX,+BAA+B,CAACY,QAAQ,EAAE;MAC5D,MAAM,IAAImB,KAAK,CACb,8DAA8D,CAC/D;;IAGH,IAAI,IAAI,CAAClB,YAAY,CAACN,MAAM,KAAKE,yBAAyB,CAACuB,cAAc,EAAE;MACzE,MAAM,IAAID,KAAK,CACb,6EAA6EtB,yBAAyB,CAACuB,cAAc,EAAE,CACxH;;IAGH,IAAIF,YAAY,CAACP,GAAG,CAACU,KAAK,IAAIH,YAAY,CAACP,GAAG,CAACU,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,KAAK,CAAC,CAAC,EAAE;MACzE,MAAM,IAAIJ,KAAK,CAAC,gDAAgD,CAAC;;IAGnE,IAAI,CAAClB,YAAY,CAACL,IAAI,CAACsB,YAAY,CAAC;EACtC;EAEA;;;;;;;EAOAM,aAAaA,CAAC;IACZC,KAAK;IACLC,MAAM;IACNC,UAAU;IACVC,MAAM;IACNC,eAAe;IACfC,UAAU;IACVC,eAAe;IACfC,YAAY;IACZC,aAAa;IACbC,mBAAmB;IACnBC,YAAY;IACZC,kBAAkB;IAClBC,UAAU;IACVC,WAAW;IACXC,cAAc;IACdC,gBAAgB;IAChBC,KAAK;IACLC,IAAI;IACJC,KAAK;IACLC,OAAO;IACPhC;EAAM,CA4CP;IACC,IAAI,IAAI,CAACb,MAAM,KAAKX,+BAA+B,CAACY,QAAQ,EAAE;MAC5D,MAAM,IAAImB,KAAK,CACb,8DAA8D,CAC/D;;IAGH,IACE,IAAI,CAAClB,YAAY,CAACN,MAAM,GAAG+B,MAAM,CAACmB,QAAQ,EAAE,GAC5ChD,yBAAyB,CAACuB,cAAc,EACxC;MACA,MAAM,IAAID,KAAK,CACb,2EAA2EtB,yBAAyB,CAACuB,cAAc,EAAE,CACtH;;IAGH,IAAIK,KAAK,KAAK,CAAC,EAAE;MACf,IACEM,eAAe,IAAI,IAAI,IACvBC,YAAY,IAAI,IAAI,IACpBC,aAAa,IAAI,IAAI,IACrBC,mBAAmB,IAAI,IAAI,IAC3BC,YAAY,IAAI,IAAI,IACpBC,kBAAkB,IAAI,IAAI,EAC1B;QACA,MAAM,IAAIjB,KAAK,CACb,mLAAmL,CACpL;;KAEJ,MAAM,IAAIW,UAAU,KAAKhD,qBAAqB,CAACgE,mBAAmB,EAAE;MACnE,IAAIf,eAAe,IAAI,IAAI,IAAIC,YAAY,IAAI,IAAI,EAAE;QACnD,MAAM,IAAIb,KAAK,CACb,kIAAkI,CACnI;;MAEH,IACEc,aAAa,IAAI,IAAI,IACrBC,mBAAmB,IAAI,IAAI,IAC3BC,YAAY,IAAI,IAAI,IACpBC,kBAAkB,IAAI,IAAI,IAC1BC,UAAU,IAAI,IAAI,EAClB;QACA,MAAM,IAAIlB,KAAK,CACb,wKAAwK,CACzK;;KAEJ,MAAM,IACLY,eAAe,IAAI,IAAI,IACvBC,YAAY,IAAI,IAAI,IACpBC,aAAa,IAAI,IAAI,IACrBC,mBAAmB,IAAI,IAAI,IAC3BC,YAAY,IAAI,IAAI,IACpBC,kBAAkB,IAAI,IAAI,IAC1BC,UAAU,IAAI,IAAI,EAClB;MACA,MAAM,IAAIlB,KAAK,CACb,uMAAuM,CACxM;;IAGH,IAAIQ,UAAU,IAAI,IAAI,EAAE;MACtB;MACAA,UAAU,GAAG,EAAE;;IAGjB,IAAIA,UAAU,CAAChC,MAAM,KAAK+B,MAAM,CAACqB,IAAI,CAACpD,MAAM,EAAE;MAC5C,MAAM,IAAIwB,KAAK,CACb,kDAAkDO,MAAM,CAACqB,IAAI,CAACpD,MAAM,SAASgC,UAAU,CAAChC,MAAM,EAAE,CACjG;;IAGH,IAAIqD,aAAa,GAAc,EAAE;IACjC,IAAIC,cAAc,GAAe,EAAE;IACnC,MAAMC,OAAO,GAA4B,EAAE;IAC3C,MAAMC,WAAW,GAAuB,EAAE;IAC1C,MAAMC,YAAY,GAAe,EAAE;IACnC,MAAMC,0BAA0B,GAAwB,IAAIlD,GAAG,EAAE;IACjE;IACA,MAAMmD,aAAa,GAAmB,CAACb,KAAK,GAAG,EAAE,GAAGA,KAAK;IAEzD,KAAK,IAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiC,UAAU,CAAChC,MAAM,EAAED,CAAC,EAAE,EAAE;MAC1C,IAAI6D,OAAO,GAAG7B,MAAM,CAACqB,IAAI,CAACrD,CAAC,CAAC,CAAC8D,IAAI;MACjC,MAAMC,QAAQ,GAAG9B,UAAU,CAACjC,CAAC,CAAC;MAE9B,IAAIrB,oBAAoB,CAACkF,OAAO,CAAC,EAAE;QACjC,IACE,CAAC5E,uBAAuB,CAAC8E,QAAQ,CAAC,IAClC,CAACxF,uBAAuB,CAACsF,OAAO,EAAEE,QAAQ,CAAC9C,GAAG,CAAC,EAC/C;UACA,MAAM,IAAIQ,KAAK,CACb,YAAYoC,OAAO,gDAAgD7D,CAAC,EAAE,CACvE;;QAEH,IAAI+D,QAAQ,CAAC9C,GAAG,CAACU,KAAK,IAAIoC,QAAQ,CAAC9C,GAAG,CAACU,KAAK,CAACC,IAAI,CAAEC,CAAC,IAAKA,CAAC,KAAK,CAAC,CAAC,EAAE;UACjE,MAAM,IAAIJ,KAAK,CAAC,gDAAgD,CAAC;;QAEnE+B,OAAO,CAACtD,IAAI,CAAC6D,QAAQ,CAAC;QACtB;;MAGF,IAAI9E,uBAAuB,CAAC8E,QAAQ,CAAC,EAAE;QACrC,MAAM,IAAItC,KAAK,CACb,wDAAwDzB,CAAC,EAAE,CAC5D;;MAGH,IAAItB,kBAAkB,CAACmF,OAAO,CAAC,EAAE;QAC/BF,0BAA0B,CAACK,GAAG,CAC5BP,WAAW,CAACxD,MAAM,EAClBqD,aAAa,CAACrD,MAAM,CACrB;QACDwD,WAAW,CAACvD,IAAI,CAAC2D,OAAO,CAAC;QACzBH,YAAY,CAACxD,IAAI,CAAC6D,QAAQ,CAAC;QAC3B;QACAF,OAAO,GAAG,IAAIjF,WAAW,CAAC,CAAC,CAAC;;MAG9B,IAAI,OAAOiF,OAAO,KAAK,QAAQ,EAAE;QAC/B,MAAM,IAAIpC,KAAK,CAAC,qBAAqBoC,OAAO,EAAE,CAAC;;MAGjDP,aAAa,CAACpD,IAAI,CAAC2D,OAAO,CAAC;MAC3BN,cAAc,CAACrD,IAAI,CAAC6D,QAAQ,CAAC;;IAG/B,MAAME,kBAAkB,GAAa,EAAE;IACvC,MAAMC,eAAe,GACnBtB,WAAW,IAAI,IAAI,GAAG,EAAE,GAAGA,WAAW,CAACuB,KAAK,EAAE;IAChD,MAAMC,WAAW,GACfvB,cAAc,IAAI,IAAI,GAAG,EAAE,GAAGA,cAAc,CAACsB,KAAK,EAAE;IACtD,MAAME,aAAa,GACjBvB,gBAAgB,IAAI,IAAI,GAAG,EAAE,GAAGA,gBAAgB,CAACqB,KAAK,EAAE;IAC1D,KAAK,IAAInE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,WAAW,CAACxD,MAAM,EAAED,CAAC,EAAE,EAAE;MAC3C,MAAMsE,OAAO,GAAGb,WAAW,CAACzD,CAAC,CAAC;MAC9B,MAAMuE,QAAQ,GAAGb,YAAY,CAAC1D,CAAC,CAAC;MAChC,IAAIwE,QAAQ,GAAG,CAAC;MAEhB,QAAQF,OAAO;QACb,KAAK9F,gBAAgB,CAACiG,OAAO;UAAE;YAC7B,MAAMC,WAAW,GAAG,IAAIpG,cAAc,EAAE;YACxC,MAAMqG,OAAO,GAAGD,WAAW,CAACE,MAAM,CAACF,WAAW,CAACG,MAAM,CAACN,QAAQ,CAAC,CAAC;YAChEC,QAAQ,GAAG7E,oBAAoB,CAACgF,OAAO,EAAET,eAAe,EAAEhC,MAAM,CAAC;YACjE;;QAEF,KAAK1D,gBAAgB,CAACsG,WAAW;UAAE;YACjC,MAAMC,UAAU,GAAG,IAAInG,WAAW,CAAC,EAAE,CAAC;YACtC,MAAMoG,QAAQ,GAAGD,UAAU,CAACH,MAAM,CAACG,UAAU,CAACF,MAAM,CAACN,QAAQ,CAAC,CAAC;YAC/D,IAAIS,QAAQ,GAAGC,MAAM,CAACC,gBAAgB,EAAE;cACtC,MAAM,IAAIzD,KAAK,CACb,oDAAoDuD,QAAQ,EAAE,CAC/D;;YAEHR,QAAQ,GAAG7E,oBAAoB,CAACsF,MAAM,CAACD,QAAQ,CAAC,EAAEZ,WAAW,EAAErC,KAAK,CAAC;YACrE;;QAEF,KAAKvD,gBAAgB,CAAC2G,KAAK;UAAE;YAC3B,MAAMJ,UAAU,GAAG,IAAInG,WAAW,CAAC,EAAE,CAAC;YACtC,MAAMwG,UAAU,GAAGL,UAAU,CAACH,MAAM,CAACG,UAAU,CAACF,MAAM,CAACN,QAAQ,CAAC,CAAC;YACjE,IAAIa,UAAU,GAAGH,MAAM,CAACC,gBAAgB,EAAE;cACxC,MAAM,IAAIzD,KAAK,CACb,8CAA8C2D,UAAU,EAAE,CAC3D;;YAEHZ,QAAQ,GAAG7E,oBAAoB,CAACsF,MAAM,CAACG,UAAU,CAAC,EAAEf,aAAa,CAAC;YAClE;;QAEF;UACE,MAAM,IAAI5C,KAAK,CAAC,2BAA2B6C,OAAO,EAAE,CAAC;;MAGzDL,kBAAkB,CAAC/D,IAAI,CAACsE,QAAQ,CAAC;;IAGnC,KAAK,IAAIxE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiE,kBAAkB,CAAChE,MAAM,EAAED,CAAC,EAAE,EAAE;MAClD,MAAMqF,aAAa,GAAG1B,0BAA0B,CAAC2B,GAAG,CAACtF,CAAC,CAAC;MACvDuD,cAAc,CAAC8B,aAAa,CAAC,GAAGpB,kBAAkB,CAACjE,CAAC,CAAC;;IAGvD,IAAIsD,aAAa,CAACrD,MAAM,GAAGR,YAAY,GAAG,CAAC,EAAE;MAC3C,MAAM8F,iBAAiB,GAAGjC,aAAa,CAACa,KAAK,CAAC1E,YAAY,GAAG,CAAC,CAAC;MAC/D,MAAM+F,kBAAkB,GAAGjC,cAAc,CAACY,KAAK,CAAC1E,YAAY,GAAG,CAAC,CAAC;MAEjE6D,aAAa,GAAGA,aAAa,CAACa,KAAK,CAAC,CAAC,EAAE1E,YAAY,GAAG,CAAC,CAAC;MACxD8D,cAAc,GAAGA,cAAc,CAACY,KAAK,CAAC,CAAC,EAAE1E,YAAY,GAAG,CAAC,CAAC;MAE1D6D,aAAa,CAACpD,IAAI,CAAC,IAAIzB,YAAY,CAAC8G,iBAAiB,CAAC,CAAC;MACvDhC,cAAc,CAACrD,IAAI,CAACsF,kBAAkB,CAAC;;IAGzC,MAAMC,cAAc,GAAiB,CAACzD,MAAM,CAAC0D,WAAW,EAAE,CAAC;IAC3D,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsD,aAAa,CAACrD,MAAM,EAAED,CAAC,EAAE,EAAE;MAC7CyF,cAAc,CAACvF,IAAI,CAACoD,aAAa,CAACtD,CAAC,CAAC,CAAC6E,MAAM,CAACtB,cAAc,CAACvD,CAAC,CAAC,CAAC,CAAC;;IAGjE,MAAM2F,OAAO,GAAG;MACd1E,GAAG,EAAEjC,gCAAgC,CAAC;QACpCQ,IAAI,EAAE0C,MAAM;QACZ0D,QAAQ,EAAE7D,KAAK;QACf8D,OAAO,EAAEJ,cAAc;QACvBK,QAAQ,EAAE5B,eAAe;QACzBE,WAAW;QACXC,aAAa;QACbtB,KAAK,EAAEa,aAAa;QACpBxB,UAAU,EACRA,UAAU,IAAI,IAAI,GAAGhD,qBAAqB,CAAC2G,MAAM,GAAG3D,UAAU;QAChEC,eAAe;QACfC,YAAY;QACZC,aAAa;QACbC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBC,UAAU;QACVM,KAAK;QACLD,IAAI;QACJE,OAAO;QACPf;OACD,CAAC;MACFjB;KACD;IAED,IAAI,CAACX,YAAY,CAACL,IAAI,CAAC,GAAGsD,OAAO,EAAEmC,OAAO,CAAC;IAC3C,IAAI,CAACnF,WAAW,CAACwD,GAAG,CAAC,IAAI,CAACzD,YAAY,CAACN,MAAM,GAAG,CAAC,EAAE+B,MAAM,CAAC;EAC5D;EAEA;;;;;EAKAgE,UAAUA,CAAA;IACR,IAAI,IAAI,CAAC3F,MAAM,KAAKX,+BAA+B,CAACY,QAAQ,EAAE;MAC5D,IAAI,IAAI,CAACC,YAAY,CAACN,MAAM,KAAK,CAAC,EAAE;QAClC,MAAM,IAAIwB,KAAK,CAAC,0CAA0C,CAAC;;MAE7D,IAAI,IAAI,CAAClB,YAAY,CAACN,MAAM,GAAG,CAAC,EAAE;QAChClB,aAAa,CACX,IAAI,CAACwB,YAAY,CAACS,GAAG,CAAEiF,aAAa,IAAKA,aAAa,CAAChF,GAAG,CAAC,CAC5D;;MAEH,IAAI,CAACZ,MAAM,GAAGX,+BAA+B,CAACwG,KAAK;;IAErD,OAAO,IAAI,CAAC3F,YAAY;EAC1B;EAEA;;;;;;;;;;EAUA,MAAM4F,gBAAgBA,CAAA;IACpB,IAAI,IAAI,CAAC9F,MAAM,IAAIX,+BAA+B,CAAC0G,MAAM,EAAE;MACzD,OAAO,IAAI,CAAC1F,UAAU;;IAGxB;IACA,MAAM2F,eAAe,GAAG,IAAI,CAACL,UAAU,EAAE;IACzC,MAAMM,QAAQ,GAAGD,eAAe,CAACrF,GAAG,CAAEiF,aAAa,IAAKA,aAAa,CAAChF,GAAG,CAAC;IAE1E,MAAMsF,gBAAgB,GAAqC,IAAI9F,GAAG,EAAE;IAEpE,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqG,eAAe,CAACpG,MAAM,EAAED,CAAC,EAAE,EAAE;MAC/C,MAAM;QAAEkB;MAAM,CAAE,GAAGmF,eAAe,CAACrG,CAAC,CAAC;MAErC,IAAI,CAACuG,gBAAgB,CAACC,GAAG,CAACtF,MAAM,CAAC,EAAE;QACjCqF,gBAAgB,CAACvC,GAAG,CAAC9C,MAAM,EAAE,EAAE,CAAC;;MAGlCqF,gBAAgB,CAACjB,GAAG,CAACpE,MAAM,CAAC,CAAChB,IAAI,CAACF,CAAC,CAAC;;IAGtC,MAAMyG,cAAc,GAAGC,KAAK,CAAClH,IAAI,CAAC+G,gBAAgB,CAAC;IAEnD,MAAMI,WAAW,GAAG,MAAMC,OAAO,CAACC,GAAG,CACnCJ,cAAc,CAACzF,GAAG,CAAC,CAAC,CAACE,MAAM,EAAE4F,OAAO,CAAC,KAAK5F,MAAM,CAACoF,QAAQ,EAAEQ,OAAO,CAAC,CAAC,CACrE;IAED,MAAMpG,UAAU,GAA6B2F,eAAe,CAACrF,GAAG,CAC9D,MAAM,IAAI,CACX;IAED,KACE,IAAI+F,WAAW,GAAG,CAAC,EACnBA,WAAW,GAAGN,cAAc,CAACxG,MAAM,EACnC8G,WAAW,EAAE,EACb;MACA,MAAMD,OAAO,GAAGL,cAAc,CAACM,WAAW,CAAC,CAAC,CAAC,CAAC;MAC9C,MAAMC,IAAI,GAAGL,WAAW,CAACI,WAAW,CAAC;MAErC,KAAK,IAAI/G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8G,OAAO,CAAC7G,MAAM,EAAED,CAAC,EAAE,EAAE;QACvCU,UAAU,CAACoG,OAAO,CAAC9G,CAAC,CAAC,CAAC,GAAGgH,IAAI,CAAChH,CAAC,CAAC;;;IAIpC,IAAI,CAACU,UAAU,CAACuG,KAAK,CAAEC,GAAG,IAAKA,GAAG,IAAI,IAAI,CAAC,EAAE;MAC3C,MAAM,IAAIzF,KAAK,CAAC,2BAA2Bf,UAAU,EAAE,CAAC;;IAG1D,MAAMC,KAAK,GAAGD,UAAU,CAACM,GAAG,CAAC,CAACmG,IAAI,EAAEC,KAAK,KAAI;MAC3C,IAAI;QACF,OAAOlI,uBAAuB,CAACiI,IAAI,CAAC,CAAClG,GAAG,CAACoG,IAAI,EAAE;OAChD,CAAC,OAAOC,GAAG,EAAE;QACZ,MAAM,IAAI7F,KAAK,CACb,6CAA6C2F,KAAK,KAAKE,GAAG,EAAE,CAC7D;;IAEL,CAAC,CAAC;IAEF,IAAI,CAAC5G,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACN,MAAM,GAAGX,+BAA+B,CAAC0G,MAAM;IAEpD,OAAO1F,UAAU;EACnB;EAEA;;;;;;;;;;;;;EAaA,MAAM6G,MAAMA,CAACC,MAAe;IAC1B,IAAI,IAAI,CAACnH,MAAM,GAAGX,+BAA+B,CAAC+H,SAAS,EAAE;MAC3D,MAAM,IAAIhG,KAAK,CAAC,yCAAyC,CAAC;;IAG5D,MAAMiG,KAAK,GAAG,MAAM,IAAI,CAACvB,gBAAgB,EAAE;IAE3C,MAAMqB,MAAM,CAACG,kBAAkB,CAACD,KAAK,CAAC,CAACE,EAAE,EAAE;IAE3C,IAAI,CAACvH,MAAM,GAAGX,+BAA+B,CAAC+H,SAAS;IAEvD,OAAO,IAAI,CAAC9G,KAAK;EACnB;EAEA;;;;;;;;;;;;;;;;EAgBA,MAAMkH,QAAQA,CACZL,MAAe,EACfM,OAAyB;IAKzB,IAAI,IAAI,CAACzH,MAAM,GAAGX,+BAA+B,CAAC+H,SAAS,EAAE;MAC3D,MAAM,IAAIhG,KAAK,CACb,uEAAuE,CACxE;;IAGH,MAAMiG,KAAK,GAAG,MAAM,IAAI,CAACvB,gBAAgB,EAAE;IAC3C,MAAM4B,UAAU,GAA+BL,KAAK,CAAC1G,GAAG,CACrDmG,IAAI,IAAK7H,QAAQ,CAACsF,MAAM,CAACuC,IAAI,CAA6B,CAC5D;IAED,MAAMa,cAAc,GAClBF,OAAO,IAAI,IAAI,GAAG,IAAIjJ,eAAe,CAAC;MAAEoJ,SAAS,EAAE;IAAE,CAAE,CAAC,GAAGH,OAAO;IAEpEE,cAAc,CAACC,SAAS,GAAG,CACzB,IAAInJ,+BAA+B,CAAC;MAClCoJ,IAAI,EAAEH;KACP,CAAC,CACH;IAED,MAAMI,gBAAgB,GAAG,MAAMX,MAAM,CAClCY,oBAAoB,CAACJ,cAAc,CAAC,CACpCJ,EAAE,EAAE;IAEP;IACA,MAAMS,aAAa,GAAgB,EAAE;IACrC,KAAK,MAAM,CAACC,QAAQ,EAAEtG,MAAM,CAAC,IAAI,IAAI,CAACxB,WAAW,EAAE;MACjD,MAAM6G,IAAI,GAAG,IAAI,CAAC1G,KAAK,CAAC2H,QAAQ,CAAC;MACjC,MAAMC,WAAW,GACfJ,gBAAgB,CAACF,SAAS,CAAC,CAAC,CAAC,CAACO,UAAU,CAACF,QAAQ,CAAC,CAACG,SAAS;MAE9D,MAAMC,YAAY,GAAc;QAC9BrB,IAAI;QACJsB,cAAc,EAAE,IAAIC,UAAU,EAAE;QAChC5G;OACD;MAEDqG,aAAa,CAACnI,IAAI,CAChBC,yBAAyB,CAAC0I,mBAAmB,CAC3C7G,MAAM,EACN0G,YAAY,EACZH,WAAW,CAACnH,oBAAoB,EAAE,CACnC,CACF;;IAGH,OAAO;MAAEiH,aAAa;MAAEF;IAAgB,CAAE;EAC5C;EAEA;;;;;;;;;;;;;;;;;EAiBA,MAAMW,OAAOA,CACXtB,MAAe,EACfuB,UAAkB;IAMlB,IAAI,IAAI,CAAC1I,MAAM,KAAKX,+BAA+B,CAACsJ,SAAS,EAAE;MAC7D,MAAM,IAAIvH,KAAK,CACb,0DAA0D,CAC3D;;IAGH,MAAMd,KAAK,GAAG,MAAM,IAAI,CAAC4G,MAAM,CAACC,MAAM,CAAC;IACvC,IAAI,CAACnH,MAAM,GAAGX,+BAA+B,CAAC+H,SAAS;IAEvD,MAAMwB,oBAAoB,GAAG,IAAI,CAAC1I,YAAY,CAAC2I,SAAS,CAAC,CAACC,CAAC,EAAE/B,KAAK,KAChE,IAAI,CAAC5G,WAAW,CAACgG,GAAG,CAACY,KAAK,CAAC,CAC5B;IACD,MAAMgC,cAAc,GAClBH,oBAAoB,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGA,oBAAoB;IACxD,MAAMI,gBAAgB,GAAG,MAAMhK,mBAAmB,CAChDmI,MAAM,EACN7G,KAAK,CAACyI,cAAc,CAAC,EACrBL,UAAU,CACX;IACD,IAAI,CAAC1I,MAAM,GAAGX,+BAA+B,CAACsJ,SAAS;IAEvD,MAAMM,cAAc,GAAWD,gBAAgB,CAAC,iBAAiB,CAAC;IAElE,MAAMhB,aAAa,GAAgB,EAAE;IAErC,KAAK,MAAM,CAACC,QAAQ,EAAEtG,MAAM,CAAC,IAAI,IAAI,CAACxB,WAAW,EAAE;MACjD,MAAM6G,IAAI,GAAG1G,KAAK,CAAC2H,QAAQ,CAAC;MAE5B,IAAII,YAAY,GAAc;QAC5BrB,IAAI;QACJsB,cAAc,EAAE,IAAIC,UAAU,EAAE;QAChC5G;OACD;MAED,IAAI;QACF,MAAMuG,WAAW,GACfD,QAAQ,KAAKW,oBAAoB,GAC7BI,gBAAgB;QAChB;QACA,MAAM7B,MAAM,CAAC+B,6BAA6B,CAAClC,IAAI,CAAC,CAACO,EAAE,EAAE;QAE3Dc,YAAY,GAAGvI,yBAAyB,CAAC0I,mBAAmB,CAC1D7G,MAAM,EACN0G,YAAY,EACZH,WAAW,CACZ;OACF,CAAC,OAAOjB,GAAG,EAAE;QACZoB,YAAY,CAACc,WAAW,GAAGlC,GAAG;;MAGhCe,aAAa,CAACnI,IAAI,CAACwI,YAAY,CAAC;;IAGlC,OAAO;MACLY,cAAc;MACd3I,KAAK;MACL0H;KACD;EACH;EAEA;;;;;;;;EAQA,OAAOQ,mBAAmBA,CACxB7G,MAAiB,EACjB0G,YAAuB,EACvBH,WAAgC;IAEhC,MAAMkB,cAAc,GAAcf,YAAY;IAC9C,IAAI;MACFe,cAAc,CAACC,MAAM,GAAGnB,WAAW;MACnC,IAAIvG,MAAM,CAAC2H,OAAO,CAAC7F,IAAI,KAAK,MAAM,EAAE;QAClC,MAAM8F,IAAI,GAAarB,WAAW,CAACqB,IAAI,IAAI,EAAE;QAC7C,IAAIA,IAAI,CAAC3J,MAAM,KAAK,CAAC,EAAE;UACrB,MAAM,IAAIwB,KAAK,CAAC,iDAAiD,CAAC;;QAGpE,MAAMoI,OAAO,GAAGxL,MAAM,CAACmB,IAAI,CAACoK,IAAI,CAACA,IAAI,CAAC3J,MAAM,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC;QAC5D,IACE4J,OAAO,CAACC,UAAU,GAAG,CAAC,IACtB,CAACD,OAAO,CAAC1F,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC4F,MAAM,CAACxK,aAAa,CAAC,EAC1C;UACA,MAAM,IAAIkC,KAAK,CAAC,iDAAiD,CAAC;;QAGpEgI,cAAc,CAACd,cAAc,GAAG,IAAIC,UAAU,CAACiB,OAAO,CAAC1F,KAAK,CAAC,CAAC,CAAC,CAAC;QAChEsF,cAAc,CAACO,WAAW,GAAGhI,MAAM,CAAC2H,OAAO,CAAC7F,IAAI,CAACc,MAAM,CACrD8D,YAAY,CAACC,cAAc,CAC5B;;KAEJ,CAAC,OAAOrB,GAAG,EAAE;MACZmC,cAAc,CAACD,WAAW,GAAGlC,GAAG;;IAGlC,OAAOmC,cAAc;EACvB;;AA7qBA;AACOtJ,yBAAA,CAAAuB,cAAc,GAAW,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}